​	

# python

### python3.8环境

```
C:\Users\1143238608\AppData\Local\Programs\Python\Python38\     
C:\Users\1143238608\AppData\Local\Programs\Python\Python38\Scripts
```

### selenium自动实现下滑

```python
js ='window.scrollTo(0,document.body.scrollHeight)'
driver.execute_script(js)
#或
js = 'document.documentElement.scrollTop = 10000'
driver.execute_script(js)

#滑动到具体处
#先获取location
next_page.location
#{'x':672,'y':5351}
driver.execute_script('window.scrollTO({},{})'.format(**next_page.loaction))

#查看元素位置及长宽
good_list = driver.find_element_by_id('J_goodsList')
good_list.rect
#{'height': 4760, 'width': 800, 'x': 190, 'y': 518}
```

### selenium自动实现键盘响应:

```python
from selenium.webdriver.commom.keys import Keys
#回车
kw.send_keys(Keys.RETURN)
```

### 无头浏览

```python
from selenium.webdriver.chrome.options import Options
chrome_option = Options()
chrome_option.add_argument('--headless')
driver = webdriver.Chrome(options=chrome_option)
```

### 实现截图

```python
driver.save_screenshot('1.jpg')
```

### python执行js:

```python
js = execjs.compile('''
        function getJsoncallback(){
            var jsoncallback = +new Date + '_' + Math.floor(Math.random() * 20000);
            return jsoncallback;
    }
    ''')

jsoncallback = js.call('getJsoncallback')
#或

js = execjs.compile(open('./wechat.js',encoding="utf-8").read())

funcName = 'getpwd("{0}")'.format('123456')

pwd = ctx.eval(funcName)
```

### python处理woff文件(关键字:@font-face)

```python
import fontTools
from fontTools.ttLib import TTFont

font = TTFont('./woff/1.woff')

print(font['glyf'].glyphOrder)

#获取数字或字体对应的unicode
font.getGlyphOrder()[2:]
#获取数字或字体的坐标
for i in font.getGlyphOrder()[2:]:
    print(font['glyf'][i].coordinates)
#使用matplotlib绘制图像
def draw(list_picture):
    list_x = []
    list_y = []
    for i in range(len(list_picture)):
        list_x.append(list_picture[i][0])
        list_y.append(list_picture[i][1])
    # print(list1,list2)
    plt.plot(list_x, list_y)
    # 去边框
    plt.axis('off')
    # 保存图片
    plt.savefig('./woff/2.jpg')
    # 展示图形
    plt.show()
```

### pythonOcr识别数字或字体

```python
import ddddocr,io
from fontTools.ttLib import TTFont
from PIL import ImageFont, Image, ImageDraw

ocr = ddddocr.DdddOcr()

tfont = TTFont("./woff/1.woff")
uni_list = tfont.getGlyphOrder()[2:]
print('uni列表：',uni_list)

charList = []
font = ImageFont.truetype("./woff/1.woff", 40)
#将10个uni字符画到im，进而使用ocr识别获得对应数字
for uchar in uni_list:
	unknown_char = f"\\u{uchar[3:]}".encode().decode("unicode_escape")
	im = Image.new(mode='RGB', size=(42, 40), color="white")
	draw = ImageDraw.Draw(im=im)
	draw.text(xy=(0, 0), text=unknown_char, fill=0, font=font)
	img_byte = io.BytesIO()
	im.save(img_byte, format='JPEG')
	charList.append(ocr.classification(img_byte.getvalue()))
print('对应字符：',charList)
```

### python实现base64编码：

```python
import base64
def base64_encode(data):
    return base64.b64encode(data.encode())

def base64_decode(data):
    return base64.b64decode(data)
print(base64_encode("巴涩").decode())
```

python实现MD5

```python
import hashlib
def md5(data):
    m = hashlib.md5()
    m.update(data.encode())
    return m.hexdigest()
```

### python写入csv文件：

```python
with open('./data.csv','a',newline='',encoding='utf-8-sig') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['商品名称','适用性别','袖型'])
    csvfile.close()
```

python写入csv文件（2）

```python
df = pd.DataFrame(resLs)
df.to_excel('./微博搜索.xlsx', index=False)
```

### python读取wasm文件

```python
Func = pywasm.load('./js/main.wasm')  //读取wasm文件
t0 = Func.exec('encode',[t1,t2])  //执行encode方法
```

### 超级鹰识别验证码

```python
import requests
from hashlib import md5


class Chaojiying_Client(object):

    def __init__(self, username, password, soft_id):
        self.username = username
        password = password.encode('utf8')
        self.password = md5(password).hexdigest()
        self.soft_id = soft_id
        self.base_params = {
            'user': self.username,
            'pass2': self.password,
            'softid': self.soft_id,
        }
        self.headers = {
            'Connection': 'Keep-Alive',
            'User-Agent': 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)',
        }

    def PostPic(self, im, codetype):
        """
        im: 图片字节
        codetype: 题目类型 参考 http://www.chaojiying.com/price.html
        """
        params = {
            'codetype': codetype,
        }
        params.update(self.base_params)
        files = {'userfile': ('ccc.jpg', im)}
        r = requests.post('http://upload.chaojiying.net/Upload/Processing.php', data=params, files=files,
                          headers=self.headers)
        return r.json()

    def ReportError(self, im_id):
        """
        im_id:报错题目的图片ID
        """
        params = {
            'id': im_id,
        }
        params.update(self.base_params)
        r = requests.post('http://upload.chaojiying.net/Upload/ReportError.php', data=params, headers=self.headers)
        return r.json()


if __name__ == '__main__':
    chaojiying = Chaojiying_Client('1143238608', '1q2w3e4r', '930525')  # 用户中心>>软件ID 生成一个替换 96001
    im = open(r'./验证码/a.jpg', 'rb').read()  # 本地图片文件路径 来替换 a.jpg 有时WIN系统须要//
    print(chaojiying.PostPic(im, 1902)['pic_str'])  # 1902 验证码类型  官方网站>>价格体系 3.4+版 print 后要加()
```

### ddddocr图像识别

```
文档：https://pypi.org/project/ddddocr/
爬虫文档：https://feapder.com/#/         
```

### 云码验证码识别

```python
import json
import time

import requests
import base64


class YdmVerify(object):
    _custom_url = "http://api.jfbym.com/api/YmServer/customApi"
    _token = "N4gM_VcNbaiuxcuZEuh4g2aI-jSj9SDdV70Du6rzStw"
    _headers = {
        'Content-Type': 'application/json'
    }



    def slide_verify(self, slide_image, background_image, verify_type="20111"):
        # 滑块类型
        # 通用双图滑块  20111
        payload = {
            "slide_image": base64.b64encode(slide_image).decode(),
            "background_image": base64.b64encode(background_image).decode(),
            "token": self._token,
            "type": verify_type
        }

        resp = requests.post(self._custom_url, headers=self._headers, data=json.dumps(payload))
        print(resp.text)
        return resp.json()['data']['data']


    def click_verify(self, image, extra=None, verify_type="30103"):
        # 通用任意点选1~4个坐标 30009
        # 通用文字点选1(extra,点选文字逗号隔开,原图) 30100
        # 定制-文字点选2(extra="click",原图) 30103
        # 定制-单图文字点选 30102
        # 定制-图标点选1(原图) 30104
        # 定制-图标点选2(原图,extra="icon") 30105
        # 定制-语序点选1(原图,extra="phrase") 30106
        # 定制-语序点选2(原图) 30107
        # 定制-空间推理点选1(原图,extra="请点击xxx") 30109
        # 定制-空间推理点选1(原图,extra="请_点击_小尺寸绿色物体。") 30110
        # 定制-tx空间点选(extra="请点击侧对着你的字母") 50009
        # 定制-tt_空间点选 30101
        # 定制-推理拼图1(原图,extra="交换2个图块") 30108
        # 定制-xy4九宫格点选(原图,label_image,image) 30008
        payload = {
            "image": base64.b64encode(image).decode(),
            "extra": 'click',
            "token": self._token,
            "type": verify_type
        }
        if extra:
            payload['extra'] = extra
        resp = requests.post(self._custom_url, headers=self._headers, data=json.dumps(payload))
        print(resp.text)
        return resp.json()['data']['data']




if __name__ == '__main__':
    y = YdmVerify()
    # slide_image = open('bg.png', 'rb').read()
    # background_image = open('full.png', 'rb').read()
    # y.slide_verify(slide_image, background_image)
    click_image = open('click.png', 'rb').read()
    y.click_verify(click_image)

```

### git上传代码

```
git add .     //将需要上传的文件添加到缓存区
git commit -m "js逆向"    //添加注释
git push     //上传文件
-------------------------------
git pull  然后再  git push
```

### python使用xpath解析

```python
import requests
from lxml import etree
if __name__=='__main__':
    # 获取页面源码数据
    url='https://bj.58.com/ershoufang/'
    # UA伪装
    head={
        'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36 Edg/97.0.1072.69'
    }
    page_text=requests.get(url=url,headers=head).text
    #数据解析
    tree =etree.HTML(page_text)
    list=tree.xpath('//div[@class="property-content-detail"]')
    fp=open('58.txt','w',encoding='utf-8')
    for h3 in list:
        #./表示定位到的div标签
        title=h3.xpath('.//text()')[0]
        print(title)
        fp.write(title+'\n')
    fp.close()
```

### Websocket

```javascript
var Socket = new WebSocket(url, [protocol] );
Socket.readyState	
        只读属性 readyState 表示连接状态，可以是以下值：

        0 - 表示连接尚未建立。

        1 - 表示连接已建立，可以进行通信。

        2 - 表示连接正在进行关闭。

        3 - 表示连接已经关闭或者连接不能打开。

Socket.bufferedAmount	
只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。

open	Socket.onopen	连接建立时触发
message	Socket.onmessage	客户端接收服务端数据时触发
Socket.send()	使用连接发送数据
Socket.close()	关闭连接

```

#### js端

```javascript
!(function () {
    if (window.flag) {
    } else {
        const websocket = new WebSocket('ws://127.0.0.1:8080')
        // 创建一个标记用来判断是否创建套接字
        window.flag = true;
        //  接收服务端发送的信息
        websocket.onmessage = function (event) {
            var data = event.data
            // 调用js解密
            var res = b(data)
            console.log(res)
            // 发送解密数据给服务端
            websocket.send(res)
        }
    }
}())
```

#### python

```python
import asyncio
import websockets
import requests


def get_res(page, sign):

    headers = {
        "Referer": "https://spa14.scrape.center/",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    }
    url = "https://spa14.scrape.center/api/movie/"
    params = {
        "limit": "10",
        "offset": page,
        "sign": sign
    }
    response = requests.get(url, headers=headers, params=params)

    print(response.text)


async def echo(websocket):
    # 使用WebSocket在客户端和服务器之间建立全双工双向连接后，就可以在连接打开时调用send()方法。
    message = 'hello world'
    # 发送数据
    await websocket.send(message)
    return True


async def recv_msg(websocket):
    while 1:
        # 接收数据
        recv_text = await websocket.recv()
        for i in range(0, 100, 10):
            print(i)
            get_res(str(i), recv_text)
            print(recv_text)


async def main_logic(websocket, path):
    await echo(websocket)
    await recv_msg(websocket)


start_server = websockets.serve(main_logic, '127.0.0.1', 8080)
loop = asyncio.get_event_loop()
loop.run_until_complete(start_server)
# 创建了一个连接对象之后，需要不断监听返回的数据，则调用 run_forever 方法，要保持长连接即可
loop.run_forever()
```



### sekiro-RPC

- 官网地址：https://sekiro.iinti.cn/sekiro-doc/

##### 1. 使用方法

###### 1. 执行方式

- 在本地开启服务端
- 需要有 Java 环境，配置参考：https://baijiahao.baidu.com/s?id=1762153534119669123&wfr=spider&for=pc
  - 下载地址:https://repo.huaweicloud.com/java/jdk/8u201-b09/
- Linux & Mac：`bin/sekiro.sh` 双击打开服务端
- Windows：`bin/sekiro.bat` 双击打开服务端

###### 2.客户端环境

- 地址：[file.virjar.com/sekiro_web_client.js?_=123](http://file.virjar.com/sekiro_web_client.js?_=123) 这个地址是在前端创建客户端的时候需要用到的代码，`Sekiro-RPC` 把他封装在一个地址里面了

###### 3.使用参数说明

- 使用原理：客户端注入到浏览器环境，然后通过` SekiroClient `和 `Sekiro `服务器通信，即可直接 `RPC` 调用浏览器内部方法，官方提供的` SekiroClient` 代码样例如下：

```JavaScript
// 生成唯一标记uuid编号
function guid() {
    function S4() {
        return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
    }
    return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
}
// 连接服务端
var client = new SekiroClient("ws://127.0.0.1:5620/business-demo/register?group=ws-group&clientId="+guid());
// 业务接口 
client.registerAction("登陆",function(request, resolve, reject){
    resolve(""+new Date());
})

```

+ **group**：业务类型（接口组），每个业务一个 `group`，`group` 下面可以注册多个终端（`SekiroClient`），同时`group` 可以挂载多个 `Action`；

+ **clientId**：指代设备，多个设备使用多个机器提供 `API` 服务，提供群控能力和负载均衡能力；

+ **SekiroClient**：服务提供者客户端，主要场景为手机/浏览器等。最终的 `Sekiro` 调用会转发到 `SekiroClient`。每个` client` 需要有一个惟一的 `clientId`；

+ **registerAction**：接口，同一个 `group` 下面可以有多个接口，分别做不同的功能；
+ **resolve**：将内容传回给服务端的方法；

+ **request**：服务端传过来的请求，如果请求里有多个参数，可以以键值对的方式从里面提取参数然后再做处理。

`Sekiro` 为我们提供了一些 API

+ 查看分组列表：http://127.0.0.1:5620/business-demo/groupList

+ 查看队列状态：http://127.0.0.1:5620/business-demo/clientQueue?group=rpc-test

+ 调用转发：http://127.0.0.1:5620/business-demo/invoke?group=rpc-test&action=clientTime

```
1.先开启服务器
2.编写注入代码
3.编写python代码
```

#### 注入js代码

```javascript
(function () {

    function SekiroClient(wsURL) {
        this.wsURL = wsURL;
        this.handlers = {};
        this.socket = {};
        this.base64 = false;
        // check
        if (!wsURL) {
            throw new Error('wsURL can not be empty!!')
        }
        this.webSocketFactory = this.resolveWebSocketFactory();
        this.connect()
    }

    SekiroClient.prototype.resolveWebSocketFactory = function () {
        if (typeof window === 'object') {
            var theWebSocket = window.WebSocket ? window.WebSocket : window.MozWebSocket;
            return function (wsURL) {

                function WindowWebSocketWrapper(wsURL) {
                    this.mSocket = new theWebSocket(wsURL);
                }

                WindowWebSocketWrapper.prototype.close = function () {
                    this.mSocket.close();
                };

                WindowWebSocketWrapper.prototype.onmessage = function (onMessageFunction) {
                    this.mSocket.onmessage = onMessageFunction;
                };

                WindowWebSocketWrapper.prototype.onopen = function (onOpenFunction) {
                    this.mSocket.onopen = onOpenFunction;
                };
                WindowWebSocketWrapper.prototype.onclose = function (onCloseFunction) {
                    this.mSocket.onclose = onCloseFunction;
                };

                WindowWebSocketWrapper.prototype.send = function (message) {
                    this.mSocket.send(message);
                };

                return new WindowWebSocketWrapper(wsURL);
            }
        }
        if (typeof weex === 'object') {
            // this is weex env : https://weex.apache.org/zh/docs/modules/websockets.html
            try {
                console.log("test webSocket for weex");
                var ws = weex.requireModule('webSocket');
                console.log("find webSocket for weex:" + ws);
                return function (wsURL) {
                    try {
                        ws.close();
                    } catch (e) {
                    }
                    ws.WebSocket(wsURL, '');
                    return ws;
                }
            } catch (e) {
                console.log(e);
                //ignore
            }
        }
        //TODO support ReactNative
        if (typeof WebSocket === 'object') {
            return function (wsURL) {
                return new theWebSocket(wsURL);
            }
        }
        // weex 鍜� PC鐜鐨剋ebsocket API涓嶅畬鍏ㄤ竴鑷达紝鎵€浠ュ仛浜嗘娊璞″吋瀹�
        throw new Error("the js environment do not support websocket");
    };

    SekiroClient.prototype.connect = function () {
        console.log('sekiro: begin of connect to wsURL: ' + this.wsURL);
        var _this = this;
        // 涓峜heck close锛岃
        // if (this.socket && this.socket.readyState === 1) {
        //     this.socket.close();
        // }
        try {
            this.socket = this.webSocketFactory(this.wsURL);
        } catch (e) {
            console.log("sekiro: create connection failed,reconnect after 2s");
            setTimeout(function () {
                _this.connect()
            }, 2000)
        }

        this.socket.onmessage(function (event) {
            _this.handleSekiroRequest(event.data)
        });

        this.socket.onopen(function (event) {
            console.log('sekiro: open a sekiro client connection')
        });

        this.socket.onclose(function (event) {
            console.log('sekiro: disconnected ,reconnection after 2s');
            setTimeout(function () {
                _this.connect()
            }, 2000)
        });
    };

    SekiroClient.prototype.handleSekiroRequest = function (requestJson) {
        console.log("receive sekiro request: " + requestJson);
        var request = JSON.parse(requestJson);
        var seq = request['__sekiro_seq__'];

        if (!request['action']) {
            this.sendFailed(seq, 'need request param {action}');
            return
        }
        var action = request['action'];
        if (!this.handlers[action]) {
            this.sendFailed(seq, 'no action handler: ' + action + ' defined');
            return
        }

        var theHandler = this.handlers[action];
        var _this = this;
        try {
            theHandler(request, function (response) {
                try {
                    _this.sendSuccess(seq, response)
                } catch (e) {
                    _this.sendFailed(seq, "e:" + e);
                }
            }, function (errorMessage) {
                _this.sendFailed(seq, errorMessage)
            })
        } catch (e) {
            console.log("error: " + e);
            _this.sendFailed(seq, ":" + e);
        }
    };

    SekiroClient.prototype.sendSuccess = function (seq, response) {
        var responseJson;
        if (typeof response == 'string') {
            try {
                responseJson = JSON.parse(response);
            } catch (e) {
                responseJson = {};
                responseJson['data'] = response;
            }
        } else if (typeof response == 'object') {
            responseJson = response;
        } else {
            responseJson = {};
            responseJson['data'] = response;
        }

        if (typeof response == 'string') {
            responseJson = {};
            responseJson['data'] = response;
        }

        if (Array.isArray(responseJson)) {
            responseJson = {
                data: responseJson,
                code: 0
            }
        }

        if (responseJson['code']) {
            responseJson['code'] = 0;
        } else if (responseJson['status']) {
            responseJson['status'] = 0;
        } else {
            responseJson['status'] = 0;
        }
        responseJson['__sekiro_seq__'] = seq;
        var responseText = JSON.stringify(responseJson);
        console.log("response :" + responseText);


        if (responseText.length < 1024 * 6) {
            this.socket.send(responseText);
            return;
        }

        if (this.base64) {
            responseText = this.base64Encode(responseText)
        }

        //澶ф姤鏂囪鍒嗘浼犺緭
        var segmentSize = 1024 * 5;
        var i = 0, totalFrameIndex = Math.floor(responseText.length / segmentSize) + 1;

        for (; i < totalFrameIndex; i++) {
            var frameData = JSON.stringify({
                    __sekiro_frame_total: totalFrameIndex,
                    __sekiro_index: i,
                    __sekiro_seq__: seq,
                    __sekiro_base64: this.base64,
                    __sekiro_is_frame: true,
                    __sekiro_content: responseText.substring(i * segmentSize, (i + 1) * segmentSize)
                }
            );
            console.log("frame: " + frameData);
            this.socket.send(frameData);
        }
    };

    SekiroClient.prototype.sendFailed = function (seq, errorMessage) {
        if (typeof errorMessage != 'string') {
            errorMessage = JSON.stringify(errorMessage);
        }
        var responseJson = {};
        responseJson['message'] = errorMessage;
        responseJson['status'] = -1;
        responseJson['__sekiro_seq__'] = seq;
        var responseText = JSON.stringify(responseJson);
        console.log("sekiro: response :" + responseText);
        this.socket.send(responseText)
    };

    SekiroClient.prototype.registerAction = function (action, handler) {
        if (typeof action !== 'string') {
            throw new Error("an action must be string");
        }
        if (typeof handler !== 'function') {
            throw new Error("a handler must be function");
        }
        console.log("sekiro: register action: " + action);
        this.handlers[action] = handler;
        return this;
    };

    SekiroClient.prototype.encodeWithBase64 = function () {
        this.base64 = arguments && arguments.length > 0 && arguments[0];
    };

    SekiroClient.prototype.base64Encode = function (s) {
        if (arguments.length !== 1) {
            throw "SyntaxError: exactly one argument required";
        }

        s = String(s);
        if (s.length === 0) {
            return s;
        }

        function _get_chars(ch, y) {
            if (ch < 0x80) y.push(ch);
            else if (ch < 0x800) {
                y.push(0xc0 + ((ch >> 6) & 0x1f));
                y.push(0x80 + (ch & 0x3f));
            } else {
                y.push(0xe0 + ((ch >> 12) & 0xf));
                y.push(0x80 + ((ch >> 6) & 0x3f));
                y.push(0x80 + (ch & 0x3f));
            }
        }

        var _PADCHAR = "=",
            _ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            _VERSION = "1.1";//Mr. Ruan fix to 1.1 to support asian char(utf8)

        //s = _encode_utf8(s);
        var i,
            b10,
            y = [],
            x = [],
            len = s.length;
        i = 0;
        while (i < len) {
            _get_chars(s.charCodeAt(i), y);
            while (y.length >= 3) {
                var ch1 = y.shift();
                var ch2 = y.shift();
                var ch3 = y.shift();
                b10 = (ch1 << 16) | (ch2 << 8) | ch3;
                x.push(_ALPHA.charAt(b10 >> 18));
                x.push(_ALPHA.charAt((b10 >> 12) & 0x3F));
                x.push(_ALPHA.charAt((b10 >> 6) & 0x3f));
                x.push(_ALPHA.charAt(b10 & 0x3f));
            }
            i++;
        }


        switch (y.length) {
            case 1:
                var ch = y.shift();
                b10 = ch << 16;
                x.push(_ALPHA.charAt(b10 >> 18) + _ALPHA.charAt((b10 >> 12) & 0x3F) + _PADCHAR + _PADCHAR);
                break;

            case 2:
                var ch1 = y.shift();
                var ch2 = y.shift();
                b10 = (ch1 << 16) | (ch2 << 8);
                x.push(_ALPHA.charAt(b10 >> 18) + _ALPHA.charAt((b10 >> 12) & 0x3F) + _ALPHA.charAt((b10 >> 6) & 0x3f) + _PADCHAR);
                break;
        }

        return x.join("");
    };

    function startRpc() {
        if (window.flag) {
        } else {
            function guid() {
                function S4() {
                    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
                }

                return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
            }

            // 创建一个标记用来判断是否创建套接字
            window.flag = true;
            var client = new SekiroClient("ws://127.0.0.1:5620/business-demo/register?group=rpc-test&clientId=" + guid());
            client.registerAction("ths", function (request, resolve, reject) {
                resolve(rt.update());
            })
        }
    }

    setTimeout(startRpc, 1000)
})()
```

#### python代码

```python
import requests

data = {
    "group": "rpc-test",
    "action": "ths",
}
res = requests.get("http://127.0.0.1:5620/business-demo/invoke", params=data)
print(res.text)
```

### 油猴脚本

**用户油猴脚本**：https://greasyfork.org/zh-CN/scripts

| 选项         | 含义                                                         |
| :----------- | :----------------------------------------------------------- |
| @name        | 脚本的名称                                                   |
| @namespace   | 命名空间，用来区分相同名称的脚本，一般写作者名字或者网址就可以 |
| @version     | 脚本版本，油猴脚本的更新会读取这个版本号                     |
| @description | 描述这个脚本是干什么用的                                     |
| @author      | 编写这个脚本的作者的名字                                     |
| **@match**   | 从字符串的起始位置匹配正则表达式，只有匹配的网址才会执行对应的脚本，例如 `*` 匹配所有，`https://www.baidu.com/*` 匹配百度等，可以参考 Python re 模块里面的 `re.match()` 方法，允许多个实例 |
| **@include** | 和 @match 类似，只有匹配的网址才会执行对应的脚本，但是 @include 不会从字符串起始位置匹配，例如 `*://*baidu.com/*` 匹配百度，具体区别可以参考 **TamperMonkey 官方文档**[8] |
| @icon        | 脚本的 icon 图标                                             |
| @grant       | 指定脚本运行所需权限，如果脚本拥有相应的权限，就可以调用油猴扩展提供的 API 与浏览器进行交互。如果设置为 none 的话，则不使用沙箱环境，脚本会直接运行在网页的环境中，这时候无法使用大部分油猴扩展的 API。如果不指定的话，油猴会默认添加几个最常用的 API |
| @require     | 如果脚本依赖其他 JS 库的话，可以使用 require 指令导入，在运行脚本之前先加载其它库 |
| **@run-at**  | 脚本注入时机，该选项是能不能 hook 到的关键，有五个值可选：`document-start`：网页开始时；`document-body`：body出现时；`document-end`：载入时或者之后执行；`document-idle`：载入完成后执行，默认选项；`context-menu`：在浏览器上下文菜单中单击该脚本时，一般将其设置为 `document-start` |

### Proxy

```
#官方文档
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy
```



### 极验滑块还原

```python
//参考文档   https://zhuanlan.zhihu.com/p/629273119
from PIL import Image
import io


def restore_img(wrong_img: bytes, right_list: list):
    fp = io.BytesIO(wrong_img)
    img = Image.open(fp)
    new_img = Image.new('RGB',(260,160),255)
    new_x,new_x_ = 0,0
    for i in range(len(right_list)):
        if i <26:
            x = right_list[i] % 26 * 12 + 1
            y = 80
            im = img.crop((x,y,x+10,160))
            new_img.paste(im,(new_x,0))
            new_x+=10
        else:
            x = right_list[i] % 26 * 12 + 1
            y = 0
            im = img.crop((x, y, x + 10, 80))
            new_img.paste(im,(new_x_,80))
            new_x_ += 10
    new_img.save('pic/bg.jpg')


if __name__ == '__main__':
    with open('pic/wrong1.jpg', 'rb') as f:
        gap = f.read()
    right_list = [39,38,48,49,41,40,46,47,35,34,50,51,33,32,28,29,27,26,36,37,31,30,44,45,43,42,12,13,23,22,14,15,21,20,8,9,25,24,6,7,3,2,0,1,11,10,4,5,19,18,16,17]
    restore_img(gap, right_list)

```

### 极验轨迹生成

```python
class Track:
    def __ease_out_expo(self, sep):
        """
        缓动函数 easeOutExpo
        参考：https://easings.net/zh-cn#easeOutExpo
        """
        if sep == 1:
            return 1
        else:
            return 1 - pow(2, -10 * sep)

    def get_slide_track(self, distance):
        """
        根据滑动距离生成滑动轨迹
        :param distance: 需要滑动的距离
        :return: 滑动轨迹<type 'list'>: [[x,y,t], ...]
            x: 已滑动的横向距离
            y: 已滑动的纵向距离, 除起点外, 均为0
            t: 滑动过程消耗的时间, 单位: 毫秒
        """

        if not isinstance(distance, int) or distance < 0:
            raise ValueError(f"distance类型必须是大于等于0的整数: distance: {distance}, type: {type(distance)}")
        # 初始化轨迹列表
        slide_track = [
            [random.randint(-50, -10), random.randint(-50, -10), 0],
            [0, 0, 0],
        ]
        # 共记录count次滑块位置信息
        count = 30 + int(distance / 2)
        # 初始化滑动时间
        t = random.randint(50, 100)
        # 记录上一次滑动的距离
        _x = 0
        _y = 0
        for i in range(count):
            # 已滑动的横向距离
            x = round(self.__ease_out_expo(i / count) * distance)
            # 滑动过程消耗的时间
            t += random.randint(10, 20)
            if x == _x:
                continue
            slide_track.append([x, _y, t])
            _x = x
        slide_track.append(slide_track[-1])
        return slide_track
```

### 数美轨迹生成

```python
import math, random
import numpy as np


def get_track(distance):
    x = [0, 0]
    y = [0, 0, 0]
    z = [0]
    count = np.linspace(-math.pi / 2, math.pi / 2, random.randrange(20, 30))
    func = list(map(math.sin, count))
    nx = [1 + 1 for i in func]
    add = random.randrange(10, 15)
    sadd = distance + add
    x.extend(list(map(lambda x: x * (sadd / 2), nx)))
    x.extend(np.linspace(sadd, distance, 3 if add > 12 else 2))
    x = [math.floor(i) for i in x]
    for i in range(len(x) - 2):
        if y[-1] < 30:
            y.append(y[-1] + random.choice([0, 0, 1, 1, 2, 2, 1, 2, 0, 0, 3, 3]))
        else:
            y.append(y[-1] + random.choice([0, 0, -1, -1, -2, -2, -1, -2, 0, 0, -3, -3]))
        for i in range(len(x) - 1):
            z.append((z[-1] // 100 * 100) + 100 + random.choice([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2]))
        trace = list(map(list, zip(x, y, z)))
        times = trace[-1][-1] + random.randint(1, 5)
        # logger.info（f模拟的轨迹--->>>{trace}）#logger.info(f'times--->>>{times})
        return trace, times
```

### 多线程

```
python程序的多线程是并发程序不是并行程序
```

```python
from threading import Thread

import requests

def install_image():
    url_list = [
            'http://pic.bizhi360.com/bbpic/98/10798.jpg',
            'http://pic.bizhi360.com/bbpic/92/10792.jpg',
            'http://pic.bizhi360.com/bbpic/86/10386.jpg'
        ]

    for url in url_list:
        response = requests.get(url).content
        with open(url.split('/')[-1],'wb') as f:
            f.write(response)

t = Thread(target=install_image)   #创建线程

t.start()      #执行线程
```

### 多进程

```python
import multiprocessing
p = multiprocessing.Process(target=get_image, args=(url,))
```

### 自定义多线程

```python
from threading import Thread
import requests

class ImageThread(Thread):
    def __init__(self,url):
        super().__init__()
        self.url=url
    def run(self):
        response = requests.get(self.url).content
        with open(self.url.split('/')[-1],'wb') as f:
            f.write(response)
url_list = [
            'http://pic.bizhi360.com/bbpic/98/10798.jpg',
            'http://pic.bizhi360.com/bbpic/92/10792.jpg',
            'http://pic.bizhi360.com/bbpic/86/10386.jpg'
        ]
for url in url_list:
    image_thread = ImageThread(url)
    image_thread.start()
```

### 多线程上锁（同步锁）

```python
from threading import Thread, RLock

num = 0
lock_obj = RLock()


def add_():
    global num
    for i in range(100000):
        lock_obj.acquire()  # 申请锁，申请成功会让其他线程等待直到当前线程释放
        num += i
        lock_obj.release()  # 释放锁，当锁被释放后其他线程才能被cpu挂起执行


def sub_():
    global num
    for i in range(100000):
        lock_obj.acquire()
        num -= i
        lock_obj.release()

t1 = Thread(target=add_)
t2 = Thread(target=sub_)
t1.start()
t2.start()

t1.join()
t2.join()
print(num)
```

### 多线程上锁（递归锁）支持嵌套使用

```python
from threading import Thread, RLock

num = 0
lock_obj = RLock()


def add_num():
    global num
    for i in range(100000):
        lock_obj.acquire()
        lock_obj.acquire()
        num += 1
        lock_obj.release()
        lock_obj.release()
    print(num)


for _ in range(2):
    t = Thread(target=add_num)
    t.start()
```

### 线程池

```python
# 模拟网页请求
import time
from concurrent.futures import ThreadPoolExecutor


def get_html(time_attr):
    time.sleep(time_attr)
    print(f'get page {time_attr} success')
    return time_attr


# 创建线程池对象
executor = ThreadPoolExecutor(max_workers=2)

# 通过submit提交需要执行的函数到线程池中，并且submit是立即返回对象不会堵塞
task_1 = executor.submit(get_html, 3)
task_2 = executor.submit(get_html, 2)

# done方法用于判定某个任务是否完成
print('task_1完成情况:', task_1.done())

# 可以使用cancel取消任务 但是运行中的任务无法取消，可以将线程数量修改成1
# print('task_2任务取消:', task_2.cancel())

# result方法可以获取任务的返回值 当前获取为阻塞
print('task_1返回结果:', task_1.result())

-------------------------------------------------------------------
with ThreadPoolExecutor(max_workers=2) as pool:
    future_list = [pool.submit(get_html,i) for i in range(5) ]

```

### 线程池

创建线程对象的期间会损耗时间，尤其是在需要开辟大量线程对象的时候会发生性能下降的情况。那么我们能否让程序创建一定数量的线程对象，并且在执行完某一个任务后不会被解释器销毁，下一个任务重复使用之前所创建的线程对象。

像这种需要创建大量线程对象的场景推荐使用线程池。



> 线程池的创建

```python
# 模拟网页请求
import time
from concurrent.futures import ThreadPoolExecutor


def get_html(time_attr):
    time.sleep(time_attr)
    print(f'get page {time_attr} success')
    return time_attr


# 创建线程池对象
executor = ThreadPoolExecutor(max_workers=2)

# 通过submit提交需要执行的函数到线程池中，并且submit是立即返回对象不会堵塞
task_1 = executor.submit(get_html, 3)
task_2 = executor.submit(get_html, 2)

# done方法用于判定某个任务是否完成
print('task_1完成情况:', task_1.done())

# 可以使用cancel取消任务 但是运行中的任务无法取消，可以将线程数量修改成1
# print('task_2任务取消:', task_2.cancel())

# result方法可以获取任务的返回值 当前获取为阻塞
print('task_1返回结果:', task_1.result())
```



> `as_completed`
>
> 获取已经执行成功的`task`的返回值

```python
# 模拟网页请求
import time
from concurrent.futures import ThreadPoolExecutor, as_completed


def get_html(time_attr):
    time.sleep(time_attr)
    print(f'get page {time_attr} success')
    return time_attr


# 创建线程池对象
executor = ThreadPoolExecutor(max_workers=2)

# 批量提交任务并获取已经执行成功的task的返回值
time_attr_list = [3, 2, 5, 4]
all_task = [executor.submit(get_html, time_attr) for time_attr in time_attr_list]
for future in as_completed(all_task):
    data = future.result()
    print(f'get page {data}')  # 线程任务只要执行完就能获取到返回值

```



> `map`
>
> 获取已经执行成功的`task`的返回值 - 代码更精简

```python
# 模拟网页请求
import time
from concurrent.futures import ThreadPoolExecutor, as_completed


def get_html(time_attr):
    time.sleep(time_attr)
    print(f'get page {time_attr} success')
    return time_attr


# 创建线程池对象
executor = ThreadPoolExecutor(max_workers=2)

# 批量提交任务并获取已经执行成功的task的返回值
time_attr_list = [3, 2, 5, 4]

# 通过executor对象中的map获取已经完成的任务的返回值
for data in executor.map(get_html, time_attr_list):
    print(f'get page {data}')  # 当前打印的返回值顺序与列表顺序一致

# all_task = [executor.submit(get_html, time_attr) for time_attr in time_attr_list]
# for future in as_completed(all_task):
#     data = future.result()
#     print(f'get page {data}')  # 线程任务只要执行完就能获取到返回值
```



> `wait`
>
> 等待指定任务完成后主线程解堵塞

```python
import time
from concurrent.futures import ThreadPoolExecutor, wait


def get_html(time_attr):
    time.sleep(time_attr)
    print(f'get page {time_attr} success')
    return time_attr


# 创建线程池对象
executor = ThreadPoolExecutor(max_workers=2)

# 批量提交任务并获取已经执行成功的task的返回值
time_attr_list = [3, 2, 5, 4]

all_task = [executor.submit(get_html, time_attr) for time_attr in time_attr_list]
wait(all_task)
print('主线程执行...')

```

### 进程、线程对比

##### 功能

- 进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ
- 线程，能够完成多任务，比如 一个QQ中的多个聊天窗口



##### 定义的不同

- 进程是系统进行资源分配和调度的一个独立单位.
- 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.



##### 区别

- 一个程序至少有一个进程,一个进程至少有一个线程.
- 线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。
- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率

- 线程不能够独立执行，必须依存在进程中
- 可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人



##### 优缺点

线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。



### 进程间通信 - `Queue`

`Process`之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。



##### `Queue`的使用

可以使用`multiprocessing`模块的`Queue`实现多进程之间的数据传递。

`Queue`本身是一个消息列队程序，首先用一个小实例来演示一下`Queue`的工作原理：

```python
from multiprocessing import Queue

q = Queue(3)  # 初始化一个Queue对象，最多可接收三条put消息
q.put("消息1")
q.put("消息2")
print(q.full())  # 判断当前队列是否已满: False
q.put("消息3")
print(q.full())  # True

# 如果队列已满put_nowait会立即抛出异常，put等待两秒会抛出异常
q.put("消息4", True, 2)
q.put_nowait("消息4")

# 推荐的方式，先判断消息列队是否已满，再写入
if not q.full():
    q.put_nowait("消息4")

# 读取消息时，先判断消息列队是否为空，再读取
if not q.empty():
    for i in range(q.qsize()):
        print(q.get_nowait())

```

**说明**

初始化`Queue()`对象时，若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；

- `Queue.qsize()`：返回当前队列包含的消息数量；
- `Queue.empty()`：如果队列为空，返回`True`，反之`False`；
- `Queue.full()`：如果队列满了，返回`True`,反之`False`；
- `Queue.get([block[, timeout]])`：获取队列中的一条消息，然后将其从列队中移除，`block`默认值为`True`；

1）如果`block`使用默认值，且没有设置`timeout`（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了`timeout`，则会等待`timeout`秒，若还没读取到任何消息，则抛出"Queue.Empty"异常；

2）如果`block`值为`False`，消息列队如果为空，则会立刻抛出"Queue.Empty"异常；

- `Queue.get_nowait()`：相当`Queue.get(False)`；
- `Queue.put(item,[block[, timeout]])`：将`item`消息写入队列，`block`默认值为`True`；

1）如果`block`使用默认值，且没有设置`timeout`（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了`timeout`，则会等待`timeout`秒，若还没空间，则抛出"Queue.Full"异常；

2）如果`block`值为`False`，消息列队如果没有空间可写入，则会立刻抛出"Queue.Full"异常；

- `Queue.put_nowait(item)`：相当`Queue.put(item, False)`



##### `Queue`实例

我们以`Queue`为例，在父进程中创建两个子进程，一个往`Queue`里写数据，一个从`Queue`里读数据：

```python
from multiprocessing import Process, Queue
import time, random


# 写数据进程执行的代码:
def write(q):
    for value in ['A', 'B', 'C']:
        print('Put %s to queue...' % value)
        q.put(value)
        time.sleep(random.random())


# 读数据进程执行的代码:
def read(q):
    while True:
        if not q.empty():
            value = q.get(True)
            print('Get %s from queue.' % value)
            time.sleep(random.random())
        else:
            break


if __name__ == '__main__':
    # 父进程创建Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    # 启动子进程pw，写入:
    pw.start()
    # 等待pw结束:
    pw.join()
    # 启动子进程pr，读取:
    pr.start()
    pr.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止:
    print('')
    print('所有数据都写入并且读完')

```



### 进程的创建 - 进程池`Pool`

##### 使用`Pool`创建进程池

当需要创建的子进程数量不多时，可以直接利用`multiprocessing`中的`Process`动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到`multiprocessing`模块提供的`Pool`方法。

初始化`Pool`时，可以指定一个最大进程数，当有新的请求提交到`Pool`中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，请看下面的实例：

```python
from multiprocessing import Pool
import os, time, random


def worker(msg):
    p_start = time.time()
    print("%s开始执行,进程号为%d" % (msg, os.getpid()))
    # random.random()随机生成0~1之间的浮点数
    time.sleep(random.random() * 2)
    p_stop = time.time()
    print(msg, "执行完毕，耗时%0.2f" % (p_stop - p_start))


if __name__ == '__main__':
    main_start = time.time()
    po = Pool(3)  # 定义一个进程池，最大进程数3
    for i in range(0, 10):
        # Pool().apply_async(要调用的目标,(传递给目标的参数元祖,))
        # 每次循环将会用空闲出来的子进程去调用目标
        po.apply_async(worker, (i,))
        # po.apply(worker, (i,))  # 同步执行 执行该方法会导致主进程堵塞

    print("----start----")
    po.close()  # 关闭进程池，关闭后po不再接收新的请求
    po.join()  # 等待po中所有子进程执行完成，必须放在close语句之后
    print("-----end-----")
    main_stop = time.time()
    print(f'耗时: {main_stop - main_start}')

```

`multiprocessing.Pool`常用函数解析：

- `apply_async(func[, args[, kwds]]) `：使用非阻塞方式调用`func`（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），`args`为传递给`func`的参数列表，`kwds`为传递给`func`的关键字参数列表
- `close()`：关闭`Pool`，使其不再接受新的任务
- `terminate()`：不管任务是否完成，立即终止
- `join()`：主进程阻塞，等待子进程的退出， 必须在`close`或`terminate`之后使用



##### 进程池中的`Queue`

如果要使用`Pool`创建进程，就需要使用`multiprocessing.Manager()`中的`Queue()`，而不是`multiprocessing.Queue()`，否则会得到一条如下的错误信息：

> RuntimeError: Queue objects should only be shared between processes through inheritance.



下面的实例演示了进程池中的进程如何通信：

```python
# 修改import中的Queue为Manager
from multiprocessing import Manager, Pool
import os, time


def reader(q):
    print("reader启动(%s),父进程为(%s)" % (os.getpid(), os.getppid()))
    for i in range(q.qsize()):
        print("reader从Queue获取到消息：%s" % q.get())


def writer(q):
    print("writer启动(%s),父进程为(%s)" % (os.getpid(), os.getppid()))
    for i in "tuling":
        q.put(i)


if __name__ == "__main__":
    print("(%s) start" % os.getpid())
    q = Manager().Queue()  # 使用Manager中的Queue
    po = Pool()
    po.apply_async(writer, (q,))
    # 等待队列写入
    time.sleep(0.1)
    po.apply_async(reader, (q,))
    po.close()
    po.join()
    print("(%s) End" % os.getpid())

```

### 协程

#### 协程（异步）

```python
async def others1():
    print('others1任务开始执行')
    await asyncio.sleep(3)
    print('others1任务执行结束')
    return '1234'


async def others2():  # <coroutine object work_2 at 0x03A2B5A8>
    print('others2任务开始执行')
    await asyncio.sleep(3)
    print('others2任务执行结束')
    return '5678'

task = [others1(), others2()]
print(task)
asyncio.run(asyncio.wait(task))
```

#### 将coroutine对象打包成task对象

```python
async def others1():
    print('others1任务开始执行')
    await asyncio.sleep(3)
    print('others1任务执行结束')
    return '1234'
task = asyncio.create_task(others1())
```



### TLS浏览器指纹

```python
pip install curl-cffi


url = 'https://tls.browserleaks.com/json'

response = requests.get(url,impersonate="chrmo101").text

print(response)
```

![image-20231127201649435](D:\test\typora_pic\image-20231127201649435.png)

### Task事务定时:

```python
import schedule
import time

def job():
    print("Hello, world!")

# Every day at 2am
schedule.every().day.at("02:00").do(job)

while True:
    schedule.run_pending()
    time.sleep(1)

```

# Python面向对象

##### 1. 如何在Python中创建类

```python
'''
class 类名:
    代码块
'''

    
# Python3示例代码
class Test:
    # 构造函数
    def __init__(self):
        pass
    
    # 实例方法
    def info(self):
        pass
```



##### 2. 类与对象

> 1. 类相当于一个代码模板，可以使用这个模板生产出多个"产品"，这个"产品"在Python中为实例对象，一句话总结：一个类可以创建多个实例对象。

> 2. 对象是类创建出来的，可以理解为一个具体事物的存在，通过这个对象我们可以使用在类中创建出来的属性与方法。

```python
class Person:
    # 使用构造方法创建实例属性
    def __init__(self, name, gender):
        self.name = name
        self.gender = gender
        
    # 创建实例方法
    def info(self):
        return f'姓名: {self.name}, 性别: {self.gender}'

# 使用类创建一个实例对象 并使用实例对象使用类中的属性与方法
person = Person('安娜', '女')

# 打印属性
print(person.name)
print(person.gender)

# 打印实例方法的返回值
print(person.info())
```



##### 3. 实例属性与实例方法

> 实例方法与普通的函数类似，不同点是实例方法是在类中定义的，并且方法中的第一个形式参数为`self`

```python
class Person:
    # 请注意当前这个方法的第一个参数为self
    def info(self):
        return '这是一个返回个人信息的实例方法...'
    
# 调用实例方法必须先要创建一个实例对象
person = Person()
print(person.info())
```



> 实例属性与之前学习的变量类似，可以存储数据。但是实例属性只能被实例对象调用。定义实例属性的方式有多种，一般使用`__init__`方法创建实例属性。

```python
class Person:
    pass

# 1.使用实例对象创建实例属性
person = Person()

person.name = '安娜'
person.age = 18
person.gender = '女'

print(person.name, person.age, person.gender)  
```

```python
# 2. 使用普通实例方法创建属性
class Person:
    def create_attr(self):
        # 定义实例属性
        self.name = '安娜'
        self.age = 18
        self.gender = '女'

# 当前定义方式必须创建实例对象后调用实例方法创建实例属性
person = Person()
person.create_attr()
print(person.name, person.age, person.gender)
```

```python
# 3. 使用构造函数创建实例属性: 最常用的一种创建实例属性的方式
class Person:
    def __init__(self):
        self.name = '安娜'
        self.age = 18
        self.gender = '女'

        
person = Person()
print(person.name, person.age, person.gender)
```

总结：

1. 使用类创建的对象是`实例对象`，类创建对象的过程为`类的实例化`
2. 如果一个类中的方法的第一个参数为`self`，那么这个方法就是`实例方法`
3. 所谓的`实例属性`其实就是一个变量，用来存储数据。`实例属性`只能被`实例对象`访问。



##### 4. 类中的`self`

在讲解`self`这个参数之前，我们必须要知道类实例化执行的大致过程！！！

1. 在内存中开辟一个空间。
2. 将类产出的实例对象存储在这个独立的空间中。

注意：类的代码与实例对象不在一个内存空间中，实例对象所占用的空间只是存储了实例属性等一些数据而已。



当我们了解到在实例化的过程中产出的实例对象保存在一个单独的内存空间之后，那么这个`self`其实就是指向了这个单独的实例对象的内存空间。

通过这一个特性，我们就可以使用`self`这个参数去访问类中的属性与方法了。一句话总结：类中的`self`指的是这个类的实例对象本身。

```python
class Person:
    def __init__(self):
        self.name = '安娜'
        
    def info(self):
        # 使用self访问实例属性
        print(self.name)
        
# 实例化类
person = Person()
person.info()
```



如果一个类创建了多个实例对象，那么`self`根据接收的实例对象的不同获取的属性也不同。

```python
class Person:
    def __init__(self, name):
        self.name = name
        
    def info(self):
        # 使用self访问实例属性
        print(self.name)

        
# 实例化多个实例对象
anna = Person('安娜')
anna.info()

shuangshuang = Person('双双')
shuangshuang.info()
```



##### 5. `__init__`方法

> 所谓的`__init__`方法其实就是一种比较特殊的实例方法，也被称之为构造方法。这个方法特殊的地方在于在类实例化的过程中会自动执行该方法，无需开发者手动执行，一般用作创建实例属性。
>
> 对于`__init__`方法我们必须知道的是：构造方法不是我们创建出来的，这个方法在`object`基类中已经实现（`object`类是所有类的父类，也被称之为基类，在Python3中的类都默认继承了这个基类，至于什么是继承，在下面的内容中会进行讲解。）
>
> 在创建`__init__`方法时需要注意的是：第一个参数必须为`self`，构造方法没有返回值，也就是说构造方法不能写`return`



```python
class Test:
    def __init__(self):
        print('这是一个构造函数，在类实例化的过程中会自动执行，无需手动调用...')
     

class Person:
    # 在构造方法中写入的形参需要在实例化的过程中传入指定的实参
    def __init__(self, name):
        # 一般使用构造方法创建实例属性
        self.name = name

# 实例化
test = Test()
person = Person('安娜')
```



##### 6. 私有属性

> 私有属性不能在类的外部调用，只能在一个类的内部使用。这种特殊属性可以提供一定的数据安全性。

```python
class Person:
    def __init__(self, name, gender):
        # 普通实例属性
        self.name = name
        # 私有属性, 创建方式: 在实例属性名称前加双下划线__
        self.__gender = gender
    
    # 私有属性只能在一个类的内部使用
    def set_gender(self, value):
        # 在当前方法中可以对传递过来的value进行判断并进行选择性的赋值。当前案例省略了这种代码需求
        self.__gender = value
        return self.__gender
    
    def get_gender(self):
        return self.__gender
    

person = Person('安娜', '女')

print(person.name)
print(person.get_gender())
person.set_gender('男')
print(person.get_gender())

# print(person.__gender) 当前获取方式会抛出异常
```



##### 7. 私有方法

> 私有方法与私有属性类似，只能在一个类的内部使用。

```python
class BankService:
    def __init__(self, money):
        # 私有属性
        self.__money = money
    
    # 实例方法
    def set_money(self, new_money):
        self.__money = new_money
        return self.__money
    
    # 私有方法
    def __get_money(self):
        return self.__money
    
    # 在普通的实例方法中调用私有方法
    def interface_get_money(self):
        return self.__get_money()
    
bs = BankService(10)
# 通过普通的实例方法调用私有方法获取私有方法的返回值
print(bs.interface_get_money())

# print(bs.__get_money()) 当前代码会抛出异常

'''
如果一个父类中定义私有属性与私有方法，那么继承这个父类的子类无法获取私有属性与私有方法
'''
```



##### 8. 对象关联

> 使用对象关联可以让两个独立存在的类相互访问。

```python
class ClassRoom:
    def __init__(self, name, stu_obj):
        self.class_room_name = name
        # 当前stu_obj接收的是另外一个类的实例对象
        self.stu_obj = stu_obj

class Student:
    def __init__(self, name):
        self.student_name = name

stu_anna = Student('安娜')
class_python = ClassRoom('python_1班', stu_anna)


'''
使用班级类的实例对象访问学生类中的实例属性
	1. 班级类中的stu_obj指向了学生类中的实例对象
	2. 学生类中的实例对象可以访问学生类中的实例属性
	3. 因为班级类中的stu_obj指向的是学生类中的实例对象，所以可以使用stu.obj访问学生类中的实例属性
'''
print(class_python.stu_obj.student_name)
```



> 利用对象关联的特性实现将多个学生关联到一个教室

```python
class ClassRoom:
    def __init__(self, name):
        self.class_room_name = name
        self.stus = list()
        
    def interface_add_stu(self, stu):
        # 使用实例方法完成对象关联
        self.stus.append(stu)

class Student:
    def __init__(self, name):
        self.student_name = name
        

# 创建教室对象
class_python = ClassRoom('python_1班')

# 创建多个学生对象
stu_anna = Student('安娜')
stu_shuangshuang = Student('双双')

# 使用interface_add_stu方法将学生类的多个实例对象添加到班级类的stus列表中
class_python.interface_add_stu(stu_anna)
class_python.interface_add_stu(stu_shuangshuang)

# 使用班级类中的stus属性访问多个学生对象中的name属性
for stu in class_python.stus:
    print(stu.student_name)
```



##### 9. 继承

> 在大多数语言中都有继承的概念，所谓的继承其实就是将已经存在的类中的属性与方法传递给一个新的类，这种行为类似于我们人类社会中的遗产继承。

```python
# 继承代码示例
class Animal:
    def __init__(self):
        print('这是动物的一些共有的行为...')
        
class Person(Animal):
    pass


class Dog(Animal):
    pass


class Cat(Animal):
    pass


person = Person()
dog = Dog()
cat = Cat()

# 通过代码执行发现在person、dog、cat这三个类的实例化过程中都执行了Animal类的构造方法
# 说明了只要子类继承了父类，那么子类也拥有了父类的方法与属性
```

在类的继承过程中有两个专业术语：父类、子类

- 父类：被继承的类
- 子类：继承的类

在一些其它资料中会将父类称之为`基类`，子类称之为`派生类`。所表达的含义都是一样的。



##### 10. 单继承

> 所谓的单继承其实就是字面意思，子类继承了一个父类。

```python
class Animal:
    def __init__(self):
        self.name = None
    
    def eat(self):
        print('吃饭...')
        
    def sleep(self):
        print('睡觉...')

        
class Person(Animal):
    pass

person = Person()
print(person.name)
person.eat()
person.sleep()

# 通过代码执行发现，子类可以打印和执行父类中的属性与方法
```



> 在子类中创建父类没有的属性并使用父类中的方法打印这些属性。

```python
class Animal:
    def eat(self):
        print('吃饭...')
        
    def sleep(self):
        print('睡觉...')
    
    def info(self):
        print(f'姓名: {self.name}, 性别: {self.gender}')
        
        
class Person(Animal):
    def __init__(self, name, gender):
        self.name = name
        self.gender = gender


person = Person('双双', '女')
person.eat()
person.sleep()
```

在使用继承时我们需要注意的是：如果需要添加新的属性与方法需要在子类中实现，不要在父类中实现新属性与新方法。原因是：只要在父类修改了代码，那么会影响所有继承这个父类的子类。

如果父类中含有私有属性与私有方法的情况下，在继承时子类不会获取父类的私有属性与私有方法。



##### 11. 多继承

> 多继承就是一个子类继承了多个父类，类似日常生活中的 "干爹"。

```python
# 多继承代码示例
class A:
    pass


class B:
    pass


# C类继承了A、B两个类
class C(A, B):
    pass
```



> 多继承的实际应用

```python
# 照相功能
class Camera:
    def take_photo(self):
        print('照相功能...')

# 打游戏功能
class PlayGame:
    def game(self):
        print('打游戏功能...')

# 创建一个手机类, 并在这个手机类中添加多个功能
class Iphone(Camera, PlayGame):
    def call(self):
        print('打电话功能...')
        

# 实例化手机类, 并使用多个功能
iphone = Iphone()
iphone.call()
iphone.take_photo()
iphone.game()
```



##### 12. 重写

> 如果一个子类中继承了一个父类，但是父类中的方法不能满足与当前的业务需求，那么我们就可以在子类中创建一个与父类同名的方法进行方法覆盖，这样的代码行为我们称之为重写。

```python
class Father:
    def play_game(self):
        print('正在玩足球游戏...')
     
    
class Son(Father):
    # 当前子类中的方法与父类方法同名,会进行方法覆盖
    def play_game(self):
        print('正在玩篮球游戏...')
      
    
son = Son()
son.play_game()
```

在之后的日常开发中如果发现一个父类中的一些方法不能满足当前业务需求，则直接在子类中创建与父类同名的方法，并实现自己需要的业务逻辑即可。需要注意的是：方法修改限于子类，不能修改父类方法。修改父类方法会影响其它的子类。



##### 13. `super` 方法

> 如果在子类使用父类中的方法，但是父类中的方法有一部分代码不满足业务需求。那么可以使用`spuer()`方法重用满足需求的部分代码。

```python
class Father:
    def play_game(self):
        print('正在玩足球游戏...')
     
    
class Son(Father):
    # 当前子类中的方法与父类方法同名,会进行方法覆盖
    def play_game(self):
        # 在当前子类方法中调用父类方法
        super().play_game()
        # 新添加的功能代码
        print('正在玩篮球游戏...')
      
    
son = Son()
son.play_game()
```

```python
# 如果父类中的部分属性可以被子类重用, 则可以使用spuer()进行属性的重载
class Father:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def __str__(self):
        # 当前方法遇到print打印该类的实例对象会触发运行, 并且__str__方法的返回值必须为字符串
        return f'姓名: {self.name}, 年龄: {self.age}'
    

class Son(Father):
    def __init__(self, name, age, gender):
        # 重用父类中的name、age属性
        super().__init__(name, age)
        self.gender = gender
    
    def __str__(self):
        return f'姓名: {self.name}, 年龄: {self.age}, 性别: {self.gender}'
    

son = Son('安娜', 18, '女')
print(son)
```

```python
# 如果父类中的属性过多, 可以使用不定长参数进行接收
class Father:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def __str__(self):
        # 当前方法遇到print打印该类的实例对象会触发运行, 并且__str__方法的返回值必须为字符串
        return f'姓名: {self.name}, 年龄: {self.age}'
    

class Son(Father):
    def __init__(self, *args, **kwargs):
        # 重用父类中的name、age属性
        super().__init__(*args)
        self.kwargs = kwargs
    
    def __str__(self):
        return f'姓名: {self.name}, 年龄: {self.age}, 其它信息: {self.kwargs}'
    
    # 获取字典数据
    def interface_get_dict(self, key):
        if self.kwargs.get(key) is None:
            return '暂无数据'
        else:
            return self.kwargs.get(key)
            
    

son = Son('安娜', 18, gender='女')
print(son)
print(son.interface_get_dict('gender'))
```

注意点：

1. 使用`spuer()`方法可以调用父类中的方法，但是不能使用`super()`方法获取或修改父类中的实例属性。如果需要请使用父类的类对象或者父类的实例对象进行获取或修改。
2. `super()`方法可以获取父类中的类属性，但是不能修改和删除。



##### 14. 多态

> 多态从字面意思上分析的话就是多种形态的意思。如果多个子类（单个子类也可以）继承了同一个父类，并且同时对同一个父类中的方法进行了重写，那么这种代码行为我们称之为多态。

```python
class Animal:
    def bark(self):
        print('动物在叫...')
        
class Person(Animal):
    def bark(self):
        print('人在叫...')
        
class Dog(Animal):
    def bark(self):
        print('狗在叫...')
        

animal = Animal()
person = Person()
dog = Dog()

animal.bark()
person.bark()
dog.bark()

# 通过上述代码发现，不同的实例对象调用相同方法名时返回了不同的行为，这种情况就是多态。
```

总结：实现多态必须满足以下条件：

- 有继承关系
- 有方法重写



##### 15. 静态方法

> 如果类中的方法的第一个参数为`self`，则调用这个方法必须通过实例对象。这种方法也被称之为实例方法。但是现在我期望在不创建实例对象的情况下也能调用类中的方法的话，那么我们就需要创建`静态方法`进行方法调用。

```python
class Person:
    @staticmethod  # 当前语法在python中称之为装饰器，装饰器内容会在之后进行讲解。
    def info():
        # 静态方法的特征是：1.被staticmethod所装饰。2.当前方法没有self参数。
        print('这是一个静态方法...')
        
        
# 使用类名.方法名来运行静态方法
Person.info()
```

总结：如果类中的某一个方法无需使用类中的属性与方法的情况下，则可以使用静态方法。



##### 16. 类属性

> 如果使用构造方法创建出来的属性我们称之为实例属性。但是实例属性与实例对象是绑定关系，每个实例对象都有自己的实例属性，并且多个实例对象中的实例属性是相互隔离的。在某些场景中多个对象需要共用一个属性的情况下，就需要使用类属性进行数据共享。

```python
# 统计学生人数
class Student:
    # 类属性
    stu_num = 0
    
    def __init__(self, name):
        self.name = name
        # 使用类名.属性名进行值的修改
        Student.stu_num += 1
        
    def info(self):
        print(f'学生名称: {self.name}, 学生人数: {Student.stu_num}')

anna = Student('安娜')
anna.info()
shuangshuang = Student('双双')
shuangshuang.info()

# 通过代码执行发现，创建一个实例对象类属性的值加1
# 类属性可以被类本身与实例对象访问
```



##### 17. 类方法

> 类方法的主要功能是对类中的类属性进行操作，相对于静态方法来说，类方法可以访问类属性，静态方法不能访问。

```python
# 统计学生人数
class Student:
    # 类属性
    stu_num = 0
    
    def __init__(self, name):
        self.name = name
        # 使用类名.属性名进行值的修改
        Student.stu_num += 1
        
    def info(self):
        print(f'学生名称: {self.name}')
    
    # 单独定义方法获取学生人数
    @classmethod
    def get_student_num(cls):
        print(f'学生人数: {cls.stu_num}')

anna = Student('安娜')
anna.info()
shuangshuang = Student('双双')
shuangshuang.info()

# 使用类名.类方法()进行方法调用
Student.get_student_num()
```

总结：

1. 定义类方法时需要使用`@staticmethod`修饰。
2. 类方法的第一个形式参数为`cls`。`cls`指向的是类对象，也就是类本身。
3. 类方法可以使用`实例对象`与`类名`调用。



##### 18. 类对象

> 一个类创建的实例属性是保存在实例对象中的，那么在类中创建的类对象保存在哪里呢？答案是类对象中。类对象保存了当前这个类的方法与类属性。实例对象通过一个特殊的方法`__class__`来访问类对象中所保存的方法与属性。

```python
class Student:
    stu_num = 0
   
	@classmethod
    def print_stu_num(cls):
        return '这是类方法返回的学生人数: {cls.stu_num}'

stu = Student()

# 使用__class__方法访问和调用类属性与类方法
# 如果这个类中存在实例方法，那么使用__class__也是可以调用的。
print(stu.__class__.stu_num)
print(stu.__class__.print_stu_num())
```



> `dir()`方法：如果想要查看一个实例对象中的所有属性与方法，可以使用`dir()`方法查看。

```python
class Student:
    stu_num = 0
   
	@classmethod
    def print_stu_num(cls):
        return '这是类方法返回的学生人数: {cls.stu_num}'

stu = Student()
print(dir(stu))
```



##### 19. 多继承以及MRO继承顺序

> 在多继承中使用`类名.__init__()`的方式进行父类方法调用

```python
print("******多继承使用类名.__init__发生的状态******\n\n")
class Parent(object):
    def __init__(self, name):
        print('parent的init开始被调用')
        self.name = name
        print('parent的init结束被调用')

class Son1(Parent):
    def __init__(self, name, age):
        print('Son1的init开始被调用')
        self.age = age
        Parent.__init__(self, name)
        print('Son1的init结束被调用')

class Son2(Parent):
    def __init__(self, name, gender):
        print('Son2的init开始被调用')
        self.gender = gender
        Parent.__init__(self, name)
        print('Son2的init结束被调用')

class Grandson(Son1, Son2):
    def __init__(self, name, age, gender):
        print('Grandson的init开始被调用')
        Son1.__init__(self, name, age)  # 单独调用父类的初始化方法
        Son2.__init__(self, name, gender)
        print('Grandson的init结束被调用')

gs = Grandson('grandson', 12, '男')
print('姓名：', gs.name)
print('年龄：', gs.age)
print('性别：', gs.gender)

print("******多继承使用类名.__init__发生的状态******\n\n")
```

运行结果：

```txt
******多继承使用类名.__init__发生的状态******
Grandson的init开始被调用
Son1的init开始被调用
parent的init开始被调用
parent的init结束被调用
Son1的init结束被调用
Son2的init开始被调用
parent的init开始被调用
parent的init结束被调用
Son2的init结束被调用
Grandson的init结束被调用
姓名： grandson
年龄： 12
性别： 男
******多继承使用类名.__init__发生的状态******
```



> 在多继承中使用`super()`进行父类方法调用

```python
print("******多继承使用super().__init__发生的状态******")
class Parent(object):
    def __init__(self, name, *args, **kwargs):  # 为避免多继承报错，使用不定长参数，接受参数
        print('parent的init开始被调用')
        self.name = name
        print('parent的init结束被调用')

class Son1(Parent):
    def __init__(self, name, age, *args, **kwargs):  # 为避免多继承报错，使用不定长参数，接受参数
        print('Son1的init开始被调用')
        self.age = age
        super().__init__(name, *args, **kwargs)  # 为避免多继承报错，使用不定长参数，接受参数
        print('Son1的init结束被调用')

class Son2(Parent):
    def __init__(self, name, gender, *args, **kwargs):  # 为避免多继承报错，使用不定长参数，接受参数
        print('Son2的init开始被调用')
        self.gender = gender
        super().__init__(name, *args, **kwargs)  # 为避免多继承报错，使用不定长参数，接受参数
        print('Son2的init结束被调用')

class Grandson(Son1, Son2):
    def __init__(self, name, age, gender):
        print('Grandson的init开始被调用')
        # 多继承时，相对于使用类名.__init__方法，要把每个父类全部写一遍
        # 而super只用一句话，执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因
        # super(Grandson, self).__init__(name, age, gender)
        super().__init__(name, age, gender)
        print('Grandson的init结束被调用')

print(Grandson.__mro__)

gs = Grandson('grandson', 12, '男')
print('姓名：', gs.name)
print('年龄：', gs.age)
print('性别：', gs.gender)
print("******多继承使用super().__init__发生的状态******\n\n")
```

运行结果：

```txt
******多继承使用super().__init__发生的状态******
(<class '__main__.Grandson'>, <class '__main__.Son1'>, <class '__main__.Son2'>, <class '__main__.Parent'>, <class 'object'>)
Grandson的init开始被调用
Son1的init开始被调用
Son2的init开始被调用
parent的init开始被调用
parent的init结束被调用
Son2的init结束被调用
Son1的init结束被调用
Grandson的init结束被调用
姓名： grandson
年龄： 12
性别： 男
******多继承使用super().__init__发生的状态******
```



上述两种调用父类的方法是有区别的

1. 如果2个子类中都继承了父类，当在子类中通过父类名调用时，`parent`被执行了2次
2. 如果2个子类中都继承了父类，当在子类中通过`super`调用时，`parent`被执行了1次



> 在单继承中使用`super()`

```python
print("******单继承使用super().__init__发生的状态******")
class Parent(object):
    def __init__(self, name):
        print('parent的init开始被调用')
        self.name = name
        print('parent的init结束被调用')

class Son(Parent):
    def __init__(self, name, age):
        print('Son1的init开始被调用')
        self.age = age
        super().__init__(name)  # 单继承不能提供全部参数
        print('Son1的init结束被调用')

class Grandson(Son):
    def __init__(self, name, age, gender):
        print('Grandson的init开始被调用')
        self.gender = gender
        super().__init__(name, age)  # 单继承不能提供全部参数
        print('Grandson的init结束被调用')

gs = Grandson('grandson', 12, '男')
print('姓名：', gs.name)
print('年龄：', gs.age)
print('性别：', gs.gender)
print("******单继承使用super().__init__发生的状态******\n\n")
```

运行结果：

```txt
******单继承使用super().__init__发生的状态******
Grandson的init开始被调用
Son1的init开始被调用
parent的init开始被调用
parent的init结束被调用
Son1的init结束被调用
Grandson的init结束被调用
姓名： grandson
年龄： 12
性别： 男
******单继承使用super().__init__发生的状态******
```



总结：

1. `super().__init__`相对于`类名.__init__`，在单继承上用法基本没有区别
2. 但在多继承上有区别，`super`方法能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次，具体看前面的输出结果
3. 多继承时，使用`super`方法，对父类的传参，由于`super`的算法导致的原因，必须把参数全部传递，否则会报错
4. 单继承时，使用`super`方法，则不能全部传递，只能传父类方法所需的参数，否则会报错
5. 多继承时，相对于使用`类名.__init__`方法，要把每个父类全部写一遍, 而使用`super`方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因



##### 20. 单例模式

> 如果对一个类进行了多次的实例化，那么在内存中产生多个实例对象。在某些场景下，并不需要多个实例对象。而是重用第一次创建的实例对象。例如：在一个类中创建了多个关于云服务器的连接信息，这些信息是不变的。那么只是需要一个实例对象来访问这些信息，而不是创建多个来占用内存。

```python
# 单例模式代码示例
class Singleton:
    _instance = None
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = object.__new__(cls)
        return cls._instance
    
    def __init__(self):
        pass

single_1 = Singleton()
single_2 = Singleton()
print(id(single_1) == id(single_2))
```

```python
class ConnectionServer:
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, '_instance'):
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self, host, port, password):
        self.host = host
        self.port = port
        self.password = password


server_1 = ConnectionServer('192.168.1.1', 1234, '123')
server_2 = ConnectionServer('192.168.1.2', 3456, '456')
print(id(server_1) == id(server_2))

print(server_1.host, server_1.port, server_1.password)
print(server_2.host, server_2.port, server_2.password)
```

总结：

1. `__new__`方法是一个特殊的方法，与`__init__`方法类似。如果在类中存在以双下划线开头并且双下划线结尾的方法名时，则这个方法我们称之为魔术方法。魔术方法在基类`object`中已经实现。
2. 在类的实例化过程中，`__new__`方法比`__init__`方法先执行。
3. `__new__`方法的第一个参数为`cls`，而不是`self`。在`object`基类源码中可以发现`__new__`方法是一个类方法。



##### 21. `object`基类

> 在Python3中，所有定义的类都默认继承了`object`。在`object`类中实现了多个方法，包括了魔术方法。

```python
# object 源码
class object:
    """
    The base class of the class hierarchy.
    
    When called, it accepts no arguments and returns a new featureless
    instance that has no instance attributes and cannot be given any.
    """
    def __delattr__(self, *args, **kwargs): # real signature unknown
        """ Implement delattr(self, name). """
        pass

    def __dir__(self, *args, **kwargs): # real signature unknown
        """ Default dir() implementation. """
        pass

    def __eq__(self, *args, **kwargs): # real signature unknown
        """ Return self==value. """
        pass

    def __format__(self, *args, **kwargs): # real signature unknown
        """ Default object formatter. """
        pass

    def __getattribute__(self, *args, **kwargs): # real signature unknown
        """ Return getattr(self, name). """
        pass

    def __ge__(self, *args, **kwargs): # real signature unknown
        """ Return self>=value. """
        pass

    def __gt__(self, *args, **kwargs): # real signature unknown
        """ Return self>value. """
        pass

    def __hash__(self, *args, **kwargs): # real signature unknown
        """ Return hash(self). """
        pass

    def __init_subclass__(self, *args, **kwargs): # real signature unknown
        """
        This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        """
        pass

    def __init__(self): # known special case of object.__init__
        """ Initialize self.  See help(type(self)) for accurate signature. """
        pass

    def __le__(self, *args, **kwargs): # real signature unknown
        """ Return self<=value. """
        pass

    def __lt__(self, *args, **kwargs): # real signature unknown
        """ Return self<value. """
        pass

    @staticmethod # known case of __new__
    def __new__(cls, *more): # known special case of object.__new__
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __ne__(self, *args, **kwargs): # real signature unknown
        """ Return self!=value. """
        pass

    def __reduce_ex__(self, *args, **kwargs): # real signature unknown
        """ Helper for pickle. """
        pass

    def __reduce__(self, *args, **kwargs): # real signature unknown
        """ Helper for pickle. """
        pass

    def __repr__(self, *args, **kwargs): # real signature unknown
        """ Return repr(self). """
        pass

    def __setattr__(self, *args, **kwargs): # real signature unknown
        """ Implement setattr(self, name, value). """
        pass

    def __sizeof__(self, *args, **kwargs): # real signature unknown
        """ Size of object in memory, in bytes. """
        pass

    def __str__(self, *args, **kwargs): # real signature unknown
        """ Return str(self). """
        pass

    @classmethod # known case
    def __subclasshook__(cls, subclass): # known special case of object.__subclasshook__
        """
        Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """
        pass

    __class__ = None # (!) forward: type, real value is "<class 'type'>"
    __dict__ = {}
    __doc__ = ''
    __module__ = ''
```



# Js逆向：

## 浏览器抓包严格按照正则匹配

```reStructuredText
\bpassword\b然后点击左边的按钮
```

## webpack扣代码：

```javascript
!(function (i){
    function n(xx){
        return i[t].call
    }
})([function a(xx){},
    function a(xx){},
    function a(xx){},
    function a(xx){},
    function a(xx){}])
```

## webpack具体实现：

```javascript
var e_;
!function(t) {
    function e(r) {
        if (n[r])
            return n[r].exports;
        var i = n[r] = {
            i: r,
            l: !1,
            exports: {}
        };
        return t[r].call(i.exports, i, i.exports, e),
        i.l = !0,
        i.exports
    }
    var n = {};
    
e_ = e;
}({
    hex_md5 : function(t, e, n) {
        function r(t) {
        return o(i(a(t)))
    }
        e.exprot = r;
    }
}）
//调用关系
 e_('hex_md5').exprot('123456') 
```

## 国密系列(sm2,sm3,sm4)

### 算法分类

| 算法名称 | 算法类别                           | 应用领域             | 特点                                                       |
| -------- | ---------------------------------- | -------------------- | ---------------------------------------------------------- |
| SM1      | 对称（分组）加密算法               | 芯片                 | 分组长度、密钥长度均为 128 比特                            |
| SM2      | 非对称（基于椭圆曲线 ECC）加密算法 | 数据加密             | ECC 椭圆曲线密码机制 256 位，相比 RSA 处理速度快，消耗更少 |
| SM3      | 散列（hash）函数算法               | 完整性校验           | 安全性及效率与 SHA-256 相当，压缩函数更复杂                |
| SM4      | 对称（分组）加密算法               | 数据加密和局域网产品 | 分组长度、密钥长度均为 128 比特，计算轮数多                |
| SM7      | 对称（分组）加密算法               | 非接触式 IC 卡       | 分组长度、密钥长度均为 128 比特                            |
| SM9      | 标识加密算法（IBE）                | 端对端离线安全通讯   | 加密强度等同于 3072 位密钥的 RSA 加密算法                  |
| ZUC      | 对称（序列）加密算法               | 移动通信 4G 网络     | 流密码                                                     |

### js实现

#### 国密sm2

```javascript
// npm install sm-crypto --save

const sm2 = require('sm-crypto').sm2
 
// 1 - C1C3C2，0 - C1C2C3，默认为1
const cipherMode = 1
 
// 获取密钥对
let keypair = sm2.generateKeyPairHex()
let publicKey = keypair.publicKey   // 公钥
let privateKey = keypair.privateKey // 私钥
 
let msgString = "this is the data to be encrypted"
let encryptData = sm2.doEncrypt(msgString, publicKey, cipherMode)    // 加密结果
let decryptData = sm2.doDecrypt(encryptData, privateKey, cipherMode) // 解密结果
 
console.log("encryptData: ", encryptData)
console.log("decryptData: ", decryptData)
```

#### 国密sm3

```javascript
const sm3 = require('sm-crypto').sm3;

const data = 'Hello, SM3!';
const hash = sm3(data);

console.log('SM3 Hash:', hash);
```

#### 国密sm4

```javascript
const sm4 = require('sm-crypto').sm4;

// 设置SM4密钥（128位，16字节）
const key = '0123456789ABCDEF0123456789ABCDEF';
// 设置SM4加解密模式（ecb、cbc、ctr等）
const mode = 'ecb';

// 加密数据
const plaintext = 'Hello, SM4!';
const ciphertext = sm4.encrypt(plaintext, key, { mode });
console.log('Encrypted:', ciphertext);

// 解密数据
const decryptedText = sm4.decrypt(ciphertext, key, { mode });
console.log('Decrypted:', decryptedText);
```

### python实现

#### sm2

```python
from gmssl import sm2
 
# 16 进制的公钥和私钥
private_key = '00B9AB0B828FF68872F21A837FC303668428DEA11DCD1B24429D0C99E24EED83D5'
public_key = 'B9C9A6E04E9C91F7BA880429273747D7EF5DDEB0BB2FF6317EB00BEF331A83081A6994B8993F3F5D6EADDDB81872266C87C018FB4162F5AF347B483E24620207'
sm2_crypt = sm2.CryptSM2(public_key=public_key, private_key=private_key)
 
# 待加密数据和加密后数据为 bytes 类型
data = b"this is the data to be encrypted"
enc_data = sm2_crypt.encrypt(data)
dec_data = sm2_crypt.decrypt(enc_data)
 
print('enc_data: ', enc_data.hex())
print('dec_data: ', dec_data)
```

#### sm3

```python
from gmssl import sm3, func


def sm3_hash(message):
    # python实现需要把编码数据转换成列表
    hash_hex = sm3.sm3_hash(func.bytes_to_list(message))
    print(hash_hex)


# main
if __name__ == '__main__':
    message = b"123"  # bytes类型
    sm3_hash(message)

```

#### sm4

```python
from gmssl import sm4, func

# 创建SM4加密对象
sm4_crypt = sm4.CryptSM4()

key = b'0123456789ABCDEF0123456789ABCDEF'

# 设置密钥
sm4_crypt.set_key(key, sm4.SM4_ENCRYPT)

# 要加密的数据
data = b"Hello, SM4!"

# 加密数据
ciphertext = sm4_crypt.crypt_ecb(func.bytes_to_list(data))

# 将加密后的数据转换为字节串
encrypted_data = bytes(func.list_to_bytes(ciphertext))

# 解密数据（如果需要）
sm4_crypt.set_key(key, sm4.SM4_DECRYPT)
decrypted_data = sm4_crypt.crypt_ecb(ciphertext)
decrypted_data = bytes(func.list_to_bytes(decrypted_data))

print("原始数据:", data.decode("utf-8"))
print("加密后的数据:", encrypted_data.hex())
print("解密后的数据:", decrypted_data.decode("utf-8"))

```



## DES加密算法

#### 1.JavaScript 实现

`DES`算法的入口参数有3个

+ `key、DATA、Mode、padding`
  + `key`为`7个字节`共56位，是DES算法的工作密钥
  + `Data`为`8个字节`64位，是要被加密或被解密的数据
  + `Mode`为`DES`的工作方式
  + `padding`为填充模式，如果加密后密文长度如果达不到指定整数倍（8个字节，16个字节），填充

```JavaScript
// 引用 crypto-js 加密模块 
var CryptoJS = require('crypto-js')

function desEncrypt() {
    var key = CryptoJS.enc.Utf8.parse(desKey),
        iv = CryptoJS.enc.Utf8.parse(desIv),
        srcs = CryptoJS.enc.Utf8.parse(text),
        // CBC 加密模式，Pkcs7 填充方式
        encrypted = CryptoJS.DES.encrypt(srcs, key, {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });
    return encrypted.toString();
}

function desDecrypt() {
    var key = CryptoJS.enc.Utf8.parse(desKey),
        iv = CryptoJS.enc.Utf8.parse(desIv),
        srcs = encryptedData,
        // CBC 加密模式，Pkcs7 填充方式
        decrypted = CryptoJS.DES.decrypt(srcs, key, {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });
    return decrypted.toString(CryptoJS.enc.Utf8);
}

var text = "I love Python!"       // 待加密对象
var desKey = "6f726c64f2c2057"    // 密钥
var desIv = "0123456789ABCDEF"    // 初始向量

var encryptedData = desEncrypt()
var decryptedData = desDecrypt()

console.log("加密字符串: ", encryptedData)
    console.log("解密字符串: ", decryptedData)

// 加密字符串:  +ndbEkWNw2QAfIYQtwC14w==
// 解密字符串:  I love Python!
```



#### 2. Python 实现

```python
pip install pyDes
```



```python
import binascii
# 加密模式 CBC，填充方式 PAD_PKCS5
from pyDes import des, CBC, PAD_PKCS5

def des_encrypt(key, text, iv):
    k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5)
    en = k.encrypt(text, padmode=PAD_PKCS5)
    return binascii.b2a_hex(en)

def des_decrypt(key, text, iv):
    k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5)
    de = k.decrypt(binascii.a2b_hex(text), padmode=PAD_PKCS5)
    return de

if __name__ == '__main__':
    secret_key = '12345678'   # 密钥
    text = 'hello world'   # 加密对象
    iv = secret_key           # 偏移量
    secret_str = des_encrypt(secret_key, text, iv)
    print('加密字符串：', secret_str)
    clear_str = des_decrypt(secret_key, secret_str, iv)
    print('解密字符串：', clear_str)


# 加密字符串：b'302d3abf2421169239f829b38a9545f1'
# 解密字符串：b'I love Python!'
```

## AES加密算法

###  JavaScript 实现

类似网站：https://www.dns.com/login.html

```javascript
// 引用 crypto-js 加密模块
var CryptoJS = require('crypto-js')

function tripleAesEncrypt() {
    var key = CryptoJS.enc.Utf8.parse(aesKey),
        iv = CryptoJS.enc.Utf8.parse(aesIv),
        srcs = CryptoJS.enc.Utf8.parse(text),
        // CBC 加密方式，Pkcs7 填充方式
        encrypted = CryptoJS.AES.encrypt(srcs, key, {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });
    return encrypted.toString();
}

function tripleAesDecrypt() {
    var key = CryptoJS.enc.Utf8.parse(aesKey),
        iv = CryptoJS.enc.Utf8.parse(aesIv),
        srcs = encryptedData,
        // CBC 加密方式，Pkcs7 填充方式
        decrypted = CryptoJS.AES.decrypt(srcs, key, {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });
    return decrypted.toString(CryptoJS.enc.Utf8);
}

var text = "I love Python!"       // 待加密对象
var aesKey = "6f726c64f2c2057c"   // 密钥，16 倍数
var aesIv = "0123456789ABCDEF"    // 偏移量，16 倍数

var encryptedData = tripleAesEncrypt()
var decryptedData = tripleAesDecrypt()

console.log("加密字符串: ", encryptedData)
console.log("解密字符串: ", decryptedData)

// 加密字符串:  dZL7TLJR786VGvuUvqYGoQ==
// 解密字符串:  I love Python!
```



## rsa扣代码：

```text
var encrypt = new JSEncrypt();
encrpy.setpublic(key);
encrypt.调用加密方法(明文);
```

## 导出方法：

```javascript
var JSEncryptExports = {};
!(function(exports) {
    var JSEncrypt = function(a) {
        return 1;
    }
    exports.JSEncrypt = JSEncrypt
})(JSEncryptExports);
```

## 从对象中导出方法：

```javascript
var md5_; 
! (function(require, exports, module) {
j = {
    hex_md5: function(s) {
        return D(c(b(s), s.length * U)).toUpperCase()
    },
    b64_md5: function(s) {
        return E(c(b(s), s.length * U))
    },
    str_md5: function(s) {
        return B(c(b(s), s.length * U))
    },
    hex_hmac_md5: function(c, a) {
        return D(_(c, a))
    },
    b64_hmac_md5: function(c, a) {
        return E(_(c, a))
    },
    str_hmac_md5: function(c, a) {
        return B(_(c, a))
    }
};
md5_ = j
})();
```

```javascript
//运行J中的hex_md5方法
md5_.hex_md5()
```



## 反调：（22集）

```reStructuredText
1.检测调试工具
2.对代码进行混淆   （sojson）
```

## js遇到 then或shift()  （18集）

```text

```

## Hook系列

```
https://www.cnblogs.com/xiaoweigege/p/14954648.html
```

## Hook Cookie

```javascript
(function() {
    //严谨模式 检查所有错误
    'use strict';
    //document 为要hook的对象   这里是hook的cookie
	var cookieTemp = "";
    Object.defineProperty(document, 'cookie', {
		//hook set方法也就是赋值的方法 
		set: function(val) {
				//这样就可以快速给下面这个代码行下断点
				//从而快速定位设置cookie的代码
            	if(val.indexOf('acw_sc_va')!=-1){
                    debugger;
                }
				console.log('Hook捕获到cookie设置->', val);
				cookieTemp = val;
				return val;
		},
		//hook get方法也就是取值的方法 
		get: function()
		{
			return cookieTemp;
		}
    });
})();
```

## Hook Contructor debugger

```javascript
(()=>{
    Function.prototype._constructor = Function.prototype.constructor;
    Function.prototype.constructor = function(){
        if(arguments&&typeof arguments[0]==='string'){
            if('debugger'===arguments[0]){
                return
            }
            return Function.prototype._constructor.apply(this,arguments);
        }
    }
})()
```

## Hook eval

```javascript
(function(){
	if(window._cr_eval)return
    window._cr_eval = window.eval;
    var myeval = function(src){
        return {}
    }
    var _myeval = myeval.bind(null);
    _myeval.tostring = window._cr_eval.tostring;
    Object.defineProperty(window,'eval',{value:_myeval})
})()
```

## Hook setInterval

```javascript
let _setInterval=setInterval;
        setInterval=function(a,b){
            if(a.toString().indexOf("debugger")!=-1){
                return null;
            }
            _setInterval(a,b);
}

```

## Hook Json Info

```javascript
var my_stringify = JSON.stringify;
JSON.stringify = function (params){
    console.log("json_stringify:", params);
    return json_stringify(params);
};

var my_parse = JSON.parse;
JSON.parse = function (params){
    console.log("json_parse:", params);
    return json_parse(params);
};

```

## Hook WebSocket Info

```javascript
WebSocket.prototype.senda = WebSocket.prototype.send;
WebSocket.prototype.send = function (data){
    console.info("Hook WebSocket", data);
    return this.senda(data)
}
```

## Hook请求头内容

```JavaScript
(function () {
    var org = window.XMLHttpRequest.prototype.setRequestHeader;
    window.XMLHttpRequest.prototype.setRequestHeader = function (key, value) {
        if (key == 'token') {
            debugger;
        }
        return org.apply(this, arguments);
    };
})();
```

## 使用FillderScript替换指定Response内容

```javascript
if(oSession.fullUrl.Contains("play.qdzhongbei.com")){
    oSession.utilDecodeResponse();
    var responseStr = oSession.GetResponseBodyAsString();//获取响应的内容
    responseStr = responseStr.replace("debugger","");
    oSession.utilSetResponseBody(responseStr);
}
```

## JSON HOOK

```javascript
(function(){
  var my_stringify = JSON.stringify;
  JSON.stringify=function(params){
    console.log("HOOK stringify",params);
    debugger
    return my_stringify(params)
  };

  var my_parse = JSON.parse;
  JSON.parse = function(params){
    console.log("HOOK parse",params);
    debugger
    return my_parse(params);
  }
})();

```

## Hook XHR

```javascript
// 代码作者：掘金tager
// xhr中的方法拦截，eg: open、send etc.
function hookFunction(funcName, config) {
  return function () {
    var args = Array.prototype.slice.call(arguments)
    // 将open参数存入xhr, 在其它事件回调中可以获取到。
    if (funcName === 'open') {
      this.xhr.open_args = args
    }
    if (config[funcName]) {
      console.log(this, 'this')
      // 配置的函数执行结果返回为true时终止调用
      var result = config[funcName].call(this, args, this.xhr)
      if (result) return result;
    }
    return this.xhr[funcName].apply(this.xhr, arguments);
  }
}

// xhr中的属性和事件的拦截
function getterFactory(attr, config) {
  return function () {
    var value = this.hasOwnProperty(attr + "_") ? this[attr + "_"] : this.xhr[attr];
    var getterHook = (config[attr] || {})["getter"]
    return getterHook && getterHook(value, this) || value
  }
}
// 在赋值时触发该工厂函数（如onload等事件）
function setterFactory(attr, config) {
  return function (value) {
    var _this = this;
    var xhr = this.xhr;
    var hook = config[attr]; // 方法或对象
    this[attr + "_"] = value;
    if (/^on/.test(attr)) {
      // note：间接的在真实的xhr上给事件绑定函数
      xhr[attr] = function (e) {
        // e = configEvent(e, _this)
        var result = hook && config[attr].call(_this, xhr, e)
        result || value.call(_this, e);
      }
    } else {
      var attrSetterHook = (hook || {})["setter"]
      value = attrSetterHook && attrSetterHook(value, _this) || value
      try {
        // 并非xhr的所有属性都是可写的
        xhr[attr] = value;
      } catch (e) {
        console.warn('xhr的' + attr + '属性不可写')
      }
    }
  }
}

// 核心拦截的handler
function xhrHook(config) {
  // 存储真实的xhr构造器, 在取消hook时，可恢复
  window.realXhr = window.realXhr || XMLHttpRequest
  // 重写XMLHttpRequest构造函数
  XMLHttpRequest = function () {
    var xhr = new window.realXhr()
    // 真实的xhr实例存储到自定义的xhr属性中
    this.xhr = xhr
    // note: 遍历实例及其原型上的属性（实例和原型链上有相同属性时，取实例属性）
    for (var attr in xhr) {
      if (Object.prototype.toString.call(xhr[attr]) === '[object Function]') {
        this[attr] = hookFunction(attr, config); // 接管xhr function
      } else {
        // attention: 如果重写XMLHttpRequest，必须要全部重写，否则在ajax中不会触发success、error（原因是3.x版本是在load事件中执行success）
        Object.defineProperty(this, attr, { // 接管xhr attr、event
          get: getterFactory(attr, config),
          set: setterFactory(attr, config),
          enumerable: true
        })
      }
    }
  }
  return window.realXhr
}

// 解除xhr拦截，归还xhr管理权
function unXhrHook() {
  if (window[realXhr]) XMLHttpRequest = window[realXhr];
  window[realXhr] = undefined;
}

// 执行部分
xhrHook({
  open: function (args, xhr) {
    console.log("open called!", args, xhr)
     // return true // 返回true将终止请求，这个就是常规拦截的精髓了
  },
  setRequestHeader: function (args, xhr) {
    console.log("setRequestHeader called!", args, xhr)
         },
  onload: function (xhr) {
    // 对响应结果做处理
    this.responseText += ' tager'
  }
})


```

## Search Decode Hook

```javascript
(function(){
for (var p in window){
 var s = p.toLowerCase();
 if (s.indexOf('encode') != -1 || s.indexOf('encry') != -1){
 console.log("encode function.\n",window[p]);
 debugger
 }
 if (s.indexOf('decode') != -1 || s.indexOf('decry') !=-1){
 console.log("decode function.\n",window[p]);
 debugger
 }
}
})();
```

## Debugger Hook

```javascript
(()=>{
Function.prototype.constructor = Function.prototype.constructor;
Function.prototype.constructor = function(){
 if(arguments && typeof arguments[0]==='string'){
 if("debugger"===arguments[0]){
  return
 }
 return Function.prototype.constructor.apply(this,arguments);
 }
}
})()

Function.prototype.constructor_ = Function.prototype.constructor;
Function.prototype.constructor = function (a) {
  if(a == "debugger") {
    return function (){};
  }
  return Function.prototype.constructor_(a);
};



setInterval_new=setInterval
setInterval=function(a,b){
if(a.indexOf("debugger")==-1){
return setInterval_new(a,b)
}
}


Function.prototype.constructor = function(){}

eval_bc = eval  
eval =function(a){
if (a===='debugger;a=asdasdasdas')
return eval_bc(a)
}

// Hook setTimeout
var setTimeout_ = setTimeout
var setTimeout = function (func, time){
  if (func == txsdefwsw){
    return function () {};
  }
  return setTimeout_(func, time)
}

```

## eval Hook

```javascript
(function() {
  if (window.cr_eval) return
  window.cr_eval = window.eval
  var myeval = function (src) {
    console.log("==== eval begin: length=" + src.length + ",caller=" + (myeval.caller && myeval.caller.name) + " ====")
    console.log(src);
    console.log("==== eval end ====")
    return window.cr_eval(src)
  }
  var _myeval = myeval.bind(null)
  _myeval.toString = window.cr_eval.toString
  Object.defineProperty(window, 'eval', { value: _myeval })
  console.log(">>>> eval injected: " + document.location + " <<<<")
})();
```

## AES加密

解密的值必须先进行base64，否则解密是无效的

```javascript
var key = CryptoJS.enc.Utf8.parse("1234567812345678");
var iv = CryptoJS.enc.Utf8.parse("1234567812345678");
//加密
function AES_Encrypt(word) {
    var srcs = CryptoJS.enc.Utf8.parse(word);
    var encrypted = CryptoJS.AES.encrypt(srcs, key, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    return encrypted.toString();
}
//解密
var word = "2eDiseYiSX62qk/WS/ZDmg==";
function AES_Decrypt(word) {
    var srcs = word;
    var decrypt = CryptoJS.AES.decrypt(srcs, key, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    return decrypt.toString(CryptoJS.enc.Utf8);
}
```

## python实现MD5

```python
b_string = bytes(_string,encoding='utf-8')
client_sign = hashlib.md5(b_string).hexdigest()
```

## RPC远程调用js代码

```javascript
案例一：  b站弹幕
window.data = t;
!function(){
	if(window.isConn){
	window.ws.send(JSON.stringify(window.data));
	}else{
		window.ws = new WebSocket('ws://127.0.0.1:9999');
		ws.onmessage = function(){
			window.isConn = true;
			window.ws.send(JSON.stringify(window.data));
		}
	}
}();
案例二：  微博登录
!function(){
     if (window.flagLX){}
     else{
    window.weiboLx = makeRequest;
    var ws = new WebSocket("ws://127.0.0.1:9999");
    window.flagLX =true;
    ws.open = function(evt){};
    ws.onmessage = function(evt){
        var lx = evt.data;
        var result = lx.split(",");
        var res = window.weiboLx(result[0],result[1],7,false);
        ws.send(JSON.stringify(res));
    }}
}();
案例3:   #抖音弹幕
window.dataLx = s.toObject();
!function(){
    var res = window.dataLx;
    if (window.flagLX){
        window.wsLX.send(JSON.stringify(res));
    } 
    else{
        var ws = new WebSocket("ws://127.0.0.1:9999");
        window.wsLX = ws;
        window.flagLX = true;
        ws.open = function(evt){};
        ws.onmessage = function(evt){
            ws.send(JSON.stringify(res));
        }
    }
}();
```

## RPC远程调用py代码

```python
import asyncio
import websockets
import json

async def conn(websocket):
    await websocket.send('connect success')

async def recv(websocket):
    while True:
        recv_text = await websocket.recv()
        recv_data = json.loads(recv_text)
        print(recv_data)

async def main(websocket):
    await conn(websocket)
    await recv(websocket)

if __name__ == '__main__':
    print("server starts")
    server = websockets.serve(main, '127.0.0.1', 9999)
    asyncio.get_event_loop().run_until_complete(server)
    asyncio.get_event_loop().run_forever()
```

## Proxy与Reflect

```javascript
var obj = new Proxy({},{
    get: function (target,propkey,receiver){
        console.log(`getting ${propkey}`);
        return Reflect.get(target,propkey,receiver)
    },
    set: function (target,propkey,receiver){
      console.log(`setting ${propkey}!`);
      return Reflect.set(target,propkey,receiver);
    }
})

obj.abc = 1234;
console.log(obj.abc)

var obj2 = Object.create(obj)
obj.abc
```

## 监控函数（修改返回值）

```javascript
function test(a, b) {
    return a + b;
}

test = new Proxy(test, {
    apply(target, thisArg, argArray) {

        let result = Reflect.apply(target, thisArg, argArray);

        console.log(`${target.name} ${thisArg} ${argArray} ${result}`);

        return result*2;
    }
})

console.log(test(1, 2))
```

## 补环境(自吐浏览器环境)

```javascript
function get_enviroment(proxy_array) {
    for (var i = 0; i < proxy_array.length; i++) {
        handler = '{\n' +
            '    get: function(target, property, receiver) {\n' +
            '        console.log("方法:", "get  ", "对象:", ' +
            '"' + proxy_array[i] + '" ,' +
            '"  属性:", property, ' +
            '"  属性类型:", ' + 'typeof property, ' +
            // '"  属性值:", ' + 'target[property], ' +
            '"  属性值类型:", typeof target[property]);\n' +
            '        return target[property];\n' +
            '    },\n' +
            '    set: function(target, property, value, receiver) {\n' +
            '        console.log("方法:", "set  ", "对象:", ' +
            '"' + proxy_array[i] + '" ,' +
            '"  属性:", property, ' +
            '"  属性类型:", ' + 'typeof property, ' +
            // '"  属性值:", ' + 'target[property], ' +
            '"  属性值类型:", typeof target[property]);\n' +
            '        return Reflect.set(...arguments);\n' +
            '    }\n' +
            '}'
        eval('try{\n' + proxy_array[i] + ';\n'
            + proxy_array[i] + '=new Proxy(' + proxy_array[i] + ', ' + handler + ')}' +
            'catch (e) {\n' + proxy_array[i] + '={};\n'
            + proxy_array[i] + '=new Proxy(' + proxy_array[i] + ', ' + handler + ')}')
    }
}
proxy_array = ['window', 'document', 'location', 'navigator', 'history', 'screen']

get_enviroment(proxy_array)
```

## 补环境(jsdom)

```javascript
const jsdom = require("jsdom");
const {JSDOM} = jsdom;
var dom = new JSDOM('<!DOCTYPE html><p>hello world</p>')
window = dom.window
document = dom.window.document
navigator = dom.window.navigator
-------------------添加参数--------------------------
const dom = new JSDOM(``, {
  url: "http://q.10jqka.com.cn/",
  referrer: "http://q.10jqka.com.cn/",
  contentType: "text/html",
  includeNodeLocations: true,
  storageQuota: 10000000
});    
```

## 补环境(selenium)

```python
import os
from selenium import webdriver

PRO_DIR = os.path.dirname(os.path.abspath(__file__))
def driver_sig(html_file):
    option = webdriver.ChromeOptions()
    option.add_argument('--disable-blink-features=AutomationControlled')
    option.add_argument('headless')
    driver = webdriver.Chrome(options=option)
    driver.get(PRO_DIR +'\\'+ html_file)
    # time.sleep(2)
    # sig = driver.execute_script('return window.aaa()')
    # print(sig)
    return driver

html_file = 'index.html'
driv = driver_sig(html_file)

print(driv.execute_script('return window.aaa()'))
```

### 实例应用

```javascript
# -*- coding: utf-8 -*-

from flask import Flask, request

from selenium import webdriver
import os
from selenium.webdriver.common.by import By
# pip install flask
from flask import Flask, jsonify

PRO_DIR = os.path.dirname(os.path.abspath(__file__))


def driver_sig(html_file):
    option = webdriver.ChromeOptions()
    option.add_argument('--disable-blink-features=AutomationControlled')
    option.add_argument('headless')
    driver = webdriver.Chrome(options=option)
    driver.get(PRO_DIR + '\\' + html_file)
    # time.sleep(2)
    # sig = driver.execute_script('return window.aaa()')
    # print(sig)
    return driver


html_file = 'index.html'
driv = driver_sig(html_file)

# 创建 Flask 应用实例
app = Flask(__name__)


# 定义路由和视图函数
@app.route('/s', methods=['get', 'post'])
def hello():
    context = {
        # 加载本地地址 生成cookie值
        'v': driv.execute_script('return window.aaa()')
    }
    # 返回cookie值
    return jsonify(context=context)



# 启动应用
if __name__ == '__main__':
    app.run()

```

## 补环境(原型链)

#### 1. 补属性

- 第1种方式,直接通过navigator来补他的隐式原型

```javascript
navigator = {}
navigator.__proto__.userAgent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'

console.log(navigator.userAgent);
console.log(Object.getOwnPropertyDescriptor(navigator, 'userAgent'));
```

- 第二种, 通过navigator创建的类来补显式原型

```javascript
var Navigator = function() {};
Navigator.prototype = {"userAgent": "123123123"};
navigator = new Navigator();
console.log(navigator.userAgent)
console.log(Object.getOwnPropertyDescriptor(navigator, 'userAgent'));
```

#### 2. 补方法

- 之前的操作

```javascript
document = {}
document.createElement = function (){}
// createElement方法在document前两级的对象当中
Object.getOwnPropertyDescriptor(document.__proto__.__proto__, 'createElement')
```

- 通过原型来补

```JavaScript
Document = function Document(){}
// Object.defineProperty 直接在一个对象上定义一个新属性，或修改其现有属性，并返回此对象。
Object.defineProperty(Document.prototype,'createElement',{
    configurable: true,
    enumerable: true,
    value: function createElement(){},
    writable: true,
})
HTMLDocument = function HTMLDocument(){}
//可以将一个指定对象的原型（即内部的隐式原型属性）设置为另一个对象
Object.setPrototypeOf(HTMLDocument.prototype,Document.prototype)
document = new HTMLDocument()

console.log(Object.getOwnPropertyDescriptor(document.__proto__.__proto__, 'createElement'));
```

#### 3. `toString`检测

在 JavaScript 中，`toString()` 是一个内置函数，用于将一个值转换为字符串。

`toString()` 方法可以应用于大部分 JavaScript 值类型，包括数字、布尔值、对象、数组等。它的返回值是表示该值的字符串。

```
document.createElement.toString()
```

正常我们补环境

```javascript
document = {}
document.createElement = function(){}
// document.createElement.toString();

// 网页上输出 function createElement() { [native code] }
document.createElement.toString =function(){
    return 'function createElement() { [native code] }'
}
```



# AST

- `path.node `:表示当前path下的node节点
- `path.toString()` :当前路径所对应的源代码 
- `path.parentPath` :用于获取当前path下的父path，多用于判断节点类型 
- `path.container` :用于获取当前path下的所有兄弟节点(包括自身) 
- `path.type` :获取当前节点类型 
- `path.get('')` :获取path的子路径
- ![image-20231226205035206](D:\test\typora_pic\image-20231226205035206.png)

```javascript
t.callExpression(t.identifier('atob'),[t.memberExpression(t.identifier('arr'), t.numericLiteral(index), true)]);
t.binaryExpression('^', t.numericLiteral(10), t.numericLiteral(20));
```



## AST混淆还原

```javascript
 /*jshint esversion: 6 */
const fs = require("fs");
const parser = require("@babel/parser");
const traverse = require("@babel/traverse")；
const t = require("@babel/types");
const generator = require("@babel/generator")；


const jscode = fs.readFileSync("./demo.js",{
    encoding:"utf-8"
});

let ast = parser.parse(jscode);





let code = generator(ast).code;

fs.writeFile('./demoNew.js',code,(error=>{}));
```

## 更改函数的参数名

```javascript
const updateParam = {
	Identifier(path){
		if(path.node.name === this.paramName){
			path.node.name = 'x';
		}else if(path.node.name ===this.paramName1){
			path.node.name = 'y';
		}
	}
};

const visitor = {
	FunctionExpression(path){
		const paramName = path.node.params[0].name;
		const paramName1 = path.node.params[1].name;
		path.traverse(updateParam,{
			paramName,
			paramName1,
		});
	}
};
traverse(ast,visitor);
```

## 改变对象属性访问方式

```javascript
traverse(ast, {
    MemberExpression(path) {
        if (t.isIdentifier(path.node.property)) {
            let name = path.node.property.name;
            path.node.property = t.stringLiteral(name);
        }
        path.node.computed = true;
    },
});
```

## 实现数值常量加密

```javascript
traverse(ast, {
	NumericLiteral(path){
		let value = path.node.value;
		let key = parseInt(Math.random() * (999999 - 100000) + 100000, 10);
		let cipherNum = value ^ key;
		path.replaceWith(t.binaryExpression('^', t.numericLiteral(cipherNum), t.numericLiteral(key)));
		//替换后的节点里也有numericLiteral节点，会造成死循环，因此需要加入path.skip()
        path.skip();
	}
});
```

## 实现字符串常量加密

```javascript
function base64Encode(e) {
	var r, a, c, h, o, t, base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	for (c = e.length, a = 0, r = ''; a < c;) {
		if (h = 255 & e.charCodeAt(a++), a == c) {
			r += base64EncodeChars.charAt(h >> 2),
			r += base64EncodeChars.charAt((3 & h) << 4),
			r += '==';
			break
		}
		if (o = e.charCodeAt(a++), a == c) {
			r += base64EncodeChars.charAt(h >> 2),
			r += base64EncodeChars.charAt((3 & h) << 4 | (240 & o) >> 4),
			r += base64EncodeChars.charAt((15 & o) << 2),
			r += '=';
			break
		}
		t = e.charCodeAt(a++),
		r += base64EncodeChars.charAt(h >> 2),
		r += base64EncodeChars.charAt((3 & h) << 4 | (240 & o) >> 4),
		r += base64EncodeChars.charAt((15 & o) << 2 | (192 & t) >> 6),
		r += base64EncodeChars.charAt(63 & t)
	}
	return r
}

traverse(ast, {
	StringLiteral(path){
		//生成callExpression参数就是字符串加密后的密文
		let encStr = t.callExpression(
			     t.identifier('atob'), 
			     [t.stringLiteral(base64Encode(path.node.value))]);
		path.replaceWith(encStr);
		//替换后的节点里也有StringLiteral节点，会造成死循环，因此需要加入path.skip()
		path.skip();
  }
});
```

## 实现数组混淆

```javascript
function base64Encode(e) {
	var r, a, c, h, o, t, base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	for (c = e.length, a = 0, r = ''; a < c;) {
		if (h = 255 & e.charCodeAt(a++), a == c) {
			r += base64EncodeChars.charAt(h >> 2),
			r += base64EncodeChars.charAt((3 & h) << 4),
			r += '==';
			break
		}
		if (o = e.charCodeAt(a++), a == c) {
			r += base64EncodeChars.charAt(h >> 2),
			r += base64EncodeChars.charAt((3 & h) << 4 | (240 & o) >> 4),
			r += base64EncodeChars.charAt((15 & o) << 2),
			r += '=';
			break
		}
		t = e.charCodeAt(a++),
		r += base64EncodeChars.charAt(h >> 2),
		r += base64EncodeChars.charAt((3 & h) << 4 | (240 & o) >> 4),
		r += base64EncodeChars.charAt((15 & o) << 2 | (192 & t) >> 6),
		r += base64EncodeChars.charAt(63 & t)
	}
	return r
}

let bigArr = [];
traverse(ast, {
	StringLiteral(path){
		let cipherText = base64Encode(path.node.value);
		let bigArrIndex = bigArr.indexOf(cipherText);
		let index = bigArrIndex;
		if(bigArrIndex == -1){
			let length = bigArr.push(cipherText);
			index = length -1;
		}
		let encStr = t.callExpression(
					t.identifier('atob'), 
					[t.memberExpression(t.identifier('arr'), 
									 t.numericLiteral(index), true)]);
		path.replaceWith(encStr);
	}
});
bigArr = bigArr.map(function(v){
  return t.stringLiteral(v);
});
bigArr = t.variableDeclarator(t.identifier('arr'), t.arrayExpression(bigArr));
bigArr = t.variableDeclaration('var', [bigArr]);
ast.program.body.unshift(bigArr);
```

## 实现数组乱序

```javascript
function base64Encode(e) {
	var r, a, c, h, o, t, base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	for (c = e.length, a = 0, r = ''; a < c;) {
		if (h = 255 & e.charCodeAt(a++), a == c) {
			r += base64EncodeChars.charAt(h >> 2),
			r += base64EncodeChars.charAt((3 & h) << 4),
			r += '==';
			break
		}
		if (o = e.charCodeAt(a++), a == c) {
			r += base64EncodeChars.charAt(h >> 2),
			r += base64EncodeChars.charAt((3 & h) << 4 | (240 & o) >> 4),
			r += base64EncodeChars.charAt((15 & o) << 2),
			r += '=';
			break
		}
		t = e.charCodeAt(a++),
		r += base64EncodeChars.charAt(h >> 2),
		r += base64EncodeChars.charAt((3 & h) << 4 | (240 & o) >> 4),
		r += base64EncodeChars.charAt((15 & o) << 2 | (192 & t) >> 6),
		r += base64EncodeChars.charAt(63 & t)
	}
	return r
}

let bigArr = [];
traverse(ast, {
	StringLiteral(path){
		let cipherText = base64Encode(path.node.value);
		let bigArrIndex = bigArr.indexOf(cipherText);
		let index = bigArrIndex;
		if(bigArrIndex == -1){
			let length = bigArr.push(cipherText);
			index = length -1;
		}
		let encStr = t.callExpression(
					t.identifier('atob'), 
					[t.memberExpression(t.identifier('arr'), 
									 t.numericLiteral(index), true)]);
		path.replaceWith(encStr);
	}
});
bigArr = bigArr.map(function(v){
  return t.stringLiteral(v);
});
//构建数组声明语句
bigArr = t.variableDeclarator(t.identifier('arr'), t.arrayExpression(bigArr));
bigArr = t.variableDeclaration('var', [bigArr]);

//读取还原数组顺序的函数，并解析成astFront
const jscodeFront = fs.readFileSync("./demoFront.js", {
	encoding: "utf-8"
  });
let astFront = parser.parse(jscodeFront);
//先把还原数组顺序的代码，加入到被混淆代码的ast中
ast.program.body.unshift(astFront.program.body[0]);
//把数组放到被混淆代码的ast最前面
ast.program.body.unshift(bigArr);
```

## 实现标识符混淆

```javascript
function renameOwnBinding(path){
	let OwnBindingObj = {},globalBindingObj = {},i=0;
	path.traverse({
		Identifier(p){
			let name = p.node.name;
			let binding = p.scope.getOwnBinding(name);
			binding&&generator(binding.scope.block).code == path +''?
			(OwnBindingObj[name] = binding):(globalBindingObj[name] = 1);
		}
	}
	);
	for(let oldName in OwnBindingObj){
		do{
			var newName = '_ox2ba6ea' + i++;
		}while(globalBindingObj[newName]);
		OwnBindingObj[oldName].scope.rename(oldName,newName);
	}
}

traverse(ast,{
	'Program|FunctionDeclaration|FunctionExpression'(path){
		renameOwnBinding(path);
	}
});
let code = generator(ast).code;
console.log(code);
```

## 实现标识符随机生成（OO混淆）

```javascript
function generatorIdentifier(decNum){
	let flag = ['O', 'o', '0'];
	let retval = [];
	while(decNum > 0){
		retval.push(decNum % 3);
		decNum = parseInt(decNum / 3);
	}
	let Identifier = retval.reverse().map(function(v){
		return flag[v]
	}).join('');
	Identifier.length < 6 ? (Identifier = ('OOOOOO' + Identifier).substr(-6)):
	Identifier[0] == '0' && (Identifier = 'O' + Identifier);
	return Identifier;
}

function renameOwnBinding(path) {
    let OwnBindingObj = {}, globalBindingObj = {}, i = 0;
    path.traverse({
        Identifier(p)  {
            let name = p.node.name;
            let binding = p.scope.getOwnBinding(name);
            binding && generator(binding.scope.block).code == path + '' ?
            (OwnBindingObj[name] = binding) : (globalBindingObj[name] = 1);
        }
    });
    for(let oldName in OwnBindingObj) {
        do {
            var newName = generatorIdentifier(i++);
        } while(globalBindingObj[newName]);
        OwnBindingObj[oldName].scope.rename(oldName, newName);
    }
}
traverse(ast, {
    'Program|FunctionExpression|FunctionDeclaration'(path) {
        renameOwnBinding(path);
    }
});
```

## 字符串的解密还原

```javascript
let decryptString = ast.program.body[2];
let decryptName = decryptString.declarations[0].id.name;

let newAst = parser.parse('');
newAst.program.body.push(ast.program.body[0]);
newAst.program.body.push(ast.program.body[1]);
newAst.program.body.push(ast.program.body[2]);
let stringDecryptFunc = generator(newAst).code;
eval(stringDecryptFunc);

traverse(ast,{
	Identifier(path){
		if(path.node.name == decryptName){
			let binding = path.scope.getBinding(decryptName);
			binding && binding.referencePaths.map(function(v){
				v.parentPath.isCallExpression()&&
				v.parentPath.replaceWith(t.stringLiteral(eval(v.parentPath + '')));
			});
		}
	}
});
```

## 还原unicode与十六进制字符串

```javascript
//将js文件重新解析一次就行
let code = generator(ast,{minified:true,jsescOption:{minimal:true}}).code;
ast = parser.parse(code);
code = generator(ast).code;
console.log(code);
```

## 总结字符串解密及Unicode与十六进制混合

```javascript
function decrypt(ast){
	let end = 3;//切片需要处理的代码块
    let newAst = parser.parse('');//新建ast
    let decrypt_code = ast.program.body.slice(0, end);//切片
    newAst.program.body = decrypt_code// 将前3个节点替换进新建ast
    let stringDecryptFunc = generator(newAst, {compact: true},).code;//转为js，由于存在格式化检测，需要指定选项，来压缩代码// 自动转义
    eval(stringDecryptFunc);//执行三部分的代码


    //TODO 2 准备工作及对解密三部分节点删除
    let stringDecryptFuncAst = ast.program.body[end - 1];// 拿到解密函数所在的节点
    let DecryptFuncName;
    try {
        DecryptFuncName = stringDecryptFuncAst.declarations[0].id.name;//拿到解密函数的名字
        // DecryptFuncName = '_0x2217';//拿到解密函数的名字
    } catch (e) {
        DecryptFuncName = stringDecryptFuncAst.id.name;//拿到解密函数的名字
    }
	var rest_code = ast.program.body.slice(end); // 剩下的节点
    ast.program.body = rest_code;//剩下的节点替换


    //TODO 3 加密数组还原
    traverse(ast, {
        CallExpression(path) {//回调表达式匹配--替换加密数组为对应的值
            if (t.isIdentifier(path.node.callee, {name: DecryptFuncName})) {       //当变量名与解密函数名相同时，就执行相应操作
                console.log(eval(path.toString()));
                try {
                    path.replaceWith(t.valueToNode(eval(path.toString())));      // 值替换节点
                } catch (e) {
                    console.log(e);
                }

            }
        },
    });
    traverse(ast, {MemberExpression: {exit: [add_Mem_str]},});  // 成员表达式字符串合并

    return ast;
}

function add_Mem_str(path) {
    let node = path.node;
    if (node.computed && t.isBinaryExpression(node.property) && node.property.operator == '+') {
        let BinNode = node.property;//属性节点
        let tmpast = parse.parse(generator(BinNode).code);
        let addstr = '';
        traverse(tmpast, {
            BinaryExpression: {
                exit: function (_p) {
                    if (t.isStringLiteral(_p.node.right) && t.isStringLiteral(_p.node.left)) {//二进制表达式左右有一个类型为字符型
                        _p.replaceWith(t.StringLiteral(eval(generator(_p.node).code)))      // 值替换节点
                    }
                    addstr = _p.toString();
                }

            }
        })
        node.property = t.Identifier(addstr);
    }
}
ast = decrypt(ast);
```

## 实现花指令处理

```javascript
function callToStr(path) {
    // 将对象进行替换
    var node = path.node;//获取路径节点
    if (!t.isObjectExpression(node.init))//不是对象表达式则退出
        return;
    var objPropertiesList = node.init.properties;    // 获取对象内所有属性
    if (objPropertiesList.length == 0) // 对象内属性列表为0则退出
        return;
    var objName = node.id.name;   // 对象名
    let scope = path.scope;//获取路径的作用域
    let binding = scope.getBinding(objName);//

    if (!binding || binding.constantViolations.length > 0) {//检查该变量的值是否被修改--一致性检测
        return;
    }
    let paths = binding.referencePaths;//绑定引用的路径
    let paths_sums=0;//路径计数

    objPropertiesList.forEach(prop => {
        var key = prop.key.value;//属性名

        if (t.isFunctionExpression(prop.value))//属性值为函数表达式
        {
            var retStmt = prop.value.body.body[0];//定位到ReturnStatement

            path.scope.traverse(path.scope.block, {
                CallExpression: function (_path) {//调用表达式匹配
                    let _path_binding = _path.scope.getBinding(objName);//当前作用域获取绑定
                    if(_path_binding!=binding)return;//两者绑定对比
                    if (!t.isMemberExpression(_path.node.callee))//成员表达式判定
                        return;
                    var _node = _path.node.callee;//回调函数节点
                    if (!t.isIdentifier(_node.object) || _node.object.name !== objName)//非标识符检测||节点对象名全等验证
                        return;
                    if (!(t.isStringLiteral(_node.property) || t.isIdentifier(_node.property)))//节点属性非可迭代字符验证||节点属性标识符验证
                        return;
                    if (!(_node.property.value == key || _node.property.name == key))//节点属性值与名称等于指定值验证
                        return;
                    if (!t.isStringLiteral(_node.property) || _node.property.value != key)//节点属性可迭代字符验证与节点属性值与指定值等于验证
                        return;

                    var args = _path.node.arguments;//获取节点的参数

                    // 二元运算
                    if (t.isBinaryExpression(retStmt.argument) && args.length === 2)//二进制表达式判定且参数为两个
                    {
                        _path.replaceWith(t.binaryExpression(retStmt.argument.operator, args[0], args[1]));//二进制表达式替换当前节点
                    }
                    // 逻辑运算
                    else if (t.isLogicalExpression(retStmt.argument) && args.length == 2)//与二元运算一样
                    {
                        _path.replaceWith(t.logicalExpression(retStmt.argument.operator, args[0], args[1]));
                    }
                    // 函数调用
                    else if (t.isCallExpression(retStmt.argument) && t.isIdentifier(retStmt.argument.callee))//回调函数表达式判定及回调参数部分判定
                    {
                        _path.replaceWith(t.callExpression(args[0], args.slice(1)))
                    }
                    paths_sums+=1;//删除计数标志
                }
            })
        } else if (t.isStringLiteral(prop.value)) {//属性值为可迭代字符类型
            var retStmt = prop.value.value;//属性值的值即A:B中的B部分
            path.scope.traverse(path.scope.block, {
                MemberExpression: function (_path) {//成员表达式
                    let _path_binding = _path.scope.getBinding(objName);//当前作用域获取绑定
                    if(_path_binding!=binding)return;//两者绑定对比
                    var _node = _path.node;
                    if (!t.isIdentifier(_node.object) || _node.object.name !== objName)//节点对象标识符验证|节点对象名验证
                        return;
                    if (!(t.isStringLiteral(_node.property) || t.isIdentifier(_node.property)))//节点属性可迭代字符验证|标识符验证
                        return;
                    if (!(_node.property.value == key || _node.property.name == key))//节点属性值与名称等于指定值验证
                        return;
                    if (!t.isStringLiteral(_node.property) || _node.property.value != key)//节点属性可迭代字符判定|节点属性值等于指定值验证
                        return;
                    _path.replaceWith(t.stringLiteral(retStmt))//节点替换
                    paths_sums+=1;//删除计数标志
                }
            })
        }
    });
    if (paths_sums == paths.length) {//若绑定的每个路径都已处理 ，则移除当前路径
        path.remove();//删除路径
    }
}
traverse(ast, {VariableDeclarator: {exit: [callToStr]},});  // 对象替换

let {code} = generator(ast,opts = {jsescOption:{"minimal":true}})
```

## 函数导出

```javascript
module.exports={
    Iil1Il
}
```

# 爬虫

## xpath

```
1.安装lxml库
	pip install lxml ‐i https://pypi.douban.com/simple
2.导入lxml.etree
	from lxml import etree
3.etree.parse() 解析本地文件
	html_tree = etree.parse('XX.html')
4.etree.HTML() 服务器响应文件
	html_tree = etree.HTML(response.read().decode('utf‐8'))
5.html_tree.xpath(xpath路径)
```

## xpath基本语法

```python
1.路径查询
    //：查找所有子孙节点，不考虑层级关系
    / ：找直接子节点
2.谓词查询
    //div[@id]
    //div[@id="maincontent"]
3.属性查询
    //@class
4.模糊查询
    //div[contains(@id, "he")]
    //div[starts‐with(@id, "he")]
5.内容查询
	//div/h1/text()
6.逻辑运算
    //div[@id="head" and @class="s_down"]
    //title | //price
```

## JsonPath

```python
jsonpath的安装及使用方式：
    pip安装：
    	pip install jsonpath
    jsonpath的使用：
        obj = json.load(open('json文件', 'r', encoding='utf‐8'))
        ret = jsonpath.jsonpath(obj, 'jsonpath语法')
```

## BeautifulSoup

```python
1.安装
	pip install bs4
2.导入
	from bs4 import BeautifulSoup
3.创建对象
    服务器响应的文件生成对象
    soup = BeautifulSoup(response.read().decode(), 'lxml')
    本地文件生成对象
    soup = BeautifulSoup(open('1.html'), 'lxml')
    注意：默认打开文件的编码格式gbk所以需要指定打开编码格式
```

## 节点定位

```python
1.根据标签名查找节点
    soup.a 【注】只能找到第一个a
    soup.a.name
    soup.a.attrs
2.函数
    (1).find(返回一个对象)
        find('a')：只找到第一个a标签find('a', title='名字')
        find('a', class_='名字')
	(2).find_all(返回一个列表)
        find_all('a') 查找到所有的a
        find_all(['a', 'span']) 返回所有的a和span
        find_all('a', limit=2) 只找前两个a
	(3).select(根据选择器得到节点对象)【推荐】
        1.element
       		eg:p
        2..class
        	eg:.firstname
        3.#id
            eg:#firstname
        4.属性选择器
            [attribute]
            eg:li = soup.select('li[class]')
            [attribute=value]
        	eg:li = soup.select('li[class="hengheng1"]')
        5.层级选择器
            element element
            div p
            element>element
            div>p
            element,element
            div,p
            eg:soup = soup.select('a,span')
```

## 节点信息

```python
(1).获取节点内容：适用于标签中嵌套标签的结构
    obj.string
    obj.get_text()【推荐】
(2).节点的属性
    tag.name 获取标签名
    eg:tag = find('li)
    print(tag.name)
    tag.attrs将属性值作为一个字典返回
(3).获取节点属性
    obj.attrs.get('title')【常用】
    obj.get('title')
    obj['title']	
```

## Selenium

```python
（1）导入：from selenium import webdriver
（2）创建谷歌浏览器操作对象：
    path = 谷歌浏览器驱动文件路径
    browser = webdriver.Chrome(path)
（3）访问网址
    url = 要访问的网址
    browser.get(url)
  (4)设置延迟  
    browser.set_page_load_timeout(4)
    
  使用：
    1.find_element_by_id
    	eg:button = browser.find_element_by_id('su')
    2.find_elements_by_name
    	eg:name = browser.find_element_by_name('wd')
    3.find_elements_by_xpath
    	eg:xpath1 = browser.find_elements_by_xpath('//input[@id="su"]')
    4.find_elements_by_tag_name
    	eg:names = browser.find_elements_by_tag_name('input')
    5.find_elements_by_css_selector
    	eg:my_input = browser.find_elements_by_css_selector('#kw')[0]
    6.find_elements_by_link_text
    	eg:browser.find_element_by_link_text("新闻")
    
    访问元素信息：
        获取元素属性
        	.get_attribute('class')
        获取元素文本
        	.text
        获取标签名
        	.tag_name
            
     交互：
    点击:click()
    输入:send_keys()
    后退操作:browser.back()
    前进操作:browser.forword()
    模拟JS滚动:
        js='document.documentElement.scrollTop=100000'
        browser.execute_script(js) 执行js代码
    获取网页代码：page_source
    退出：browser.quit()

```

## Phantomjs

```python
（1）获取PhantomJS.exe文件路径path
（2）browser = webdriver.PhantomJS(path)
（3）browser.get(url)
扩展：保存屏幕快照:browser.save_screenshot('baidu.png')
```

# Scrapy

```python
scrapy startproject my_spider   #创建项目
scrapy genspider douban movie.douban.com/top250  
scrapy crawl douban         #启动项目
```



# Mysql

## 开启sql服务

```
net start MySQL80
```

## 关闭sql服务

```mysql
net stop MySQL80
```

## 查询数据库

```mysql
## 显示当前mysql中的数据库列表
show databases;
## 显示指定名称的数据库创建的SQL指令
show create database db_test;
```

## 创建数据库

```mysql
## 创建数据库 db_test表示创建的数据库名称，可以自定义
create database db_test ;
## 创建数据库，当指定名称的数据库不存在时执行创建
create database if not exists db_test;
## 在创建数据库的同时指定数据库的字符集（字符集：数据存储在数据库中采用的编码格式
utf8 gbk）
create database db_test character set utf8;
```

## 修改数据库

```mysql
## 修改数据库的字符集
alter database db_test character set utf8; # utf8 gbk
```

## 删除数据库

```mysql
## 删除数据库
drop database db_test;
## 如果数据库存在则删除数据库
drop database if exists db_test;
```

## 使用\切换数据库

```mysql
use db_test
```

## 创建数据表

```mysql
create table students(
    stu_num int primary key auto_increment,
    stu_name varchar(20) not null,
    stu_gender char(2) not null,
    stu_age int not null,
    stu_tel char(11) not null unique,
    stu_qq varchar(11) unique
);
```

## 查询全部数据表

```mysql
show tables;
```

## 查询表结构

```mysql
desc students;
```

## 删除数据表

```mysql
## 删除数据表
drop table students;
## 当数据表存在时删除数据表
drop table if exists students;
```

## 修改数据表

```mysql
## 修改表名
alter table <tableName> rename to <newTableName>;
## 数据表也是有字符集的，默认字符集和数据库一致，当然也可以通过以下语句进行修改
alter table <tableName> character set utf8;
## 添加列（字段）
alter table <tableName> add <columnName> varchar(200);
## 修改列（字段）的列表和类型
alter table <tableName> change <oldColumnName> <newCloumnName> <type>;
## 只修改列（字段）类型
alter table <tableName> modify <columnName> <newType>;
## 删除列（字段）
alter table stus drop <columnName>;
```

##   删除数据表主键约束

```mysql
alter table books drop primary key;
```

## 创建表之后添加主键约束

```mysql
alter table books modify book_isbn char(4) primary key;
```

## 删除数据

```mysql
## 删除学号为20230102的学生信息
delete from stus where stu_num='20230102';
## 删除年龄大于20岁的学生信息(如果满足where子句的记录有多条，则删除多条记录)
delete from stus where stu_age>20;
## 如果删除语句没有where子句，则表示删除当前数据表中的所有记录(敏感操作)
delete from stus;
```

## 修改数据

```mysql
## 将学号为20230105的学生姓名修改为“孙七”（只修改一列）
update stus set stu_name='孙七' where stu_num='20230105';
## 将学号为20230103的学生 性别修改为“男”,同时将QQ修改为 777777（修改多列）
update stus set stu_gender='男',stu_qq='777777' where stu_num='20230103';
## 根据主键修改其他所有列
update stus set stu_name='韩梅
梅',stu_gender='女',stu_age=18,stu_tel='13131313311' ,stu_qq='999999' where
stu_num='20230102';
## 如果update语句没有where子句，则表示修改当前表中所有行（记录）
update stus set stu_name='Tom';
```

## 条件逻辑运算符

```sql
## and 并且 筛选多个条件同时满足的记录
select * from stus where stu_gender='女' and stu_age<21;
## or 或者 筛选多个条件中至少满足一个条件的记录
select * from stus where stu_gender='女' or stu_age<21;
## not 取反
select * from stus where stu_age not between 18 and 20;
```

## LIKE 子句

```sql
# 查询学生姓名包含字母o的学生信息
select * from stus where stu_name like '%o%';
# 查询学生姓名第一个字为`张`的学生信息
select * from stus where stu_name like '张%';
# 查询学生姓名最后一个字母为o的学生信息
select * from stus where stu_name like '%y';
# 查询学生姓名中第二个字母为o的学生信息
select * from stus where stu_name like '_o%';
```

## 计算列

```sql
select stu_name as 姓名,2021-stu_age as 出生年份 from stus;
```

## distinct 消除重复行

```sql
select distinct stu_age from stus;
```

## 排序 - order by

```sql
select * from stus where stu_age>15 order by stu_gender asc,stu_age desc;
```

## 聚合函数

```sql
--------count
# 统计学生表中学生总数
select count(stu_num) from stus;
# 统计学生表中学生总数
select count(stu_num) from stus;
--------max
select max(stu_age) from stus where stu_gender='女';
--------min
select max(stu_age) from stus where stu_gender='女';
--------sum
# 计算所有性别为男的学生的年龄的综合
select sum(stu_age) from stus where stu_gender='男';
--------avg
select avg(stu_age) from stus where stu_gender='男';
```

## 日期函数 和 字符串函数

```sql
alter table students add stu_enrollment datetime;   //添加日期类型的字段
insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enrollment)values('20200108','张小三','女',20,'13434343344','123111','2022-09-0109:00:00');
-------通过now()获取当前时间
insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enrollment)
values('20210109','张小四','女',20,'13434343355','1233333',now());
-------通过sysdate()获取当前时间
insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enrollment)
values('20210110','李雷','男',16,'13434343366','123333344',sysdate());
-----------------------------------------------------------------
# concat(colnum1,colunm2,...) 拼接多列
select concat(stu_name,'-',stu_gender) from stus;
# concat(colnum1,colunm2,...) 拼接多列
select upper(stu_name) from stus;
# lower(column) 将指定列的值转换成小写
select lower(stu_name) from stus;
# substring(column,start,len) 从指定列中截取部分显示 start从1开始
select stu_name,substring(stu_tel,8,4) from stus;
```

## 分组查询 - group by

```sql
# 先对查询的学生信息按性别进行分组（分成了男、女两组），然后再分别统计每组学生的个数
select stu_gender,count(stu_num) from stus group by stu_gender;
# 先对查询的学生信息按性别进行分组（分成了男、女两组），然后再计算每组的平均年龄
select stu_gender,avg(stu_age) from stus group by stu_gender;
# 先对学生按年龄进行分组（分了16、17、18、20、21、22六组），然后统计各组的学生数量，还可以对最终的结果排序
select stu_age,count(stu_num) from stus group by stu_age order by stu_age;
# 查询所有学生，按年龄进行分组，然后分别统计每组的人数，再筛选当前组人数>1的组，再按年龄升序显示出来
select stu_age,count(stu_num) from stus group by stu_age having count(stu_num)>1 order by stu_age;
# 查询性别为'男'的学生，按年龄进行分组，然后分别统计每组的人数，再筛选当前组人数>1的组，再按年龄升序显示出来
 select stu_age,count(stu_num) from stus where stu_gender='男' group by stu_age having count(stu_num)>1 order by stu_age;
```

## 分页查询 - limit

```sql
# 查询第一页：
select * from stus [where ...] limit 0,3;
```

## 连接查询

```mysql
create table classes(
    class_id int primary key auto_increment,
    class_name varchar(40) not null unique,
    class_remark varchar(200)
);
create table students(
    stu_num char(8) primary key,
    stu_name varchar(20) not null,
    stu_gender char(2) not null,
    stu_age int not null,
    cid int,
    constraint FK_STUDENTS_CLASSES foreign key(cid) references
    classes(class_id) ON UPDATE CASCADE ON DELETE CASCADE
);

```

## 内连接 INNER JOIN

```sql
select * from students INNER JOIN classes ON students.cid = classes.class_id;
```

## 左连接 LEFT JOIN

```sql
# 语法
select * from leftTabel LEFT JOIN rightTable ON 匹配条件 [where 条件];
-- 左连接 : 显示左表中的所有记录
select * from students LEFT JOIN classes ON students.cid = classes.class_id;
```

## 右连接 RIGHT JOIN

```sql
-- 右连接 ：显示右表中的所有记录
select * from students RIGHT JOIN classes ON students.cid = classes.class_id;
```

## 数据表别名

```sql
select s.name,c.name from students s INNER JOIN classes c ON s.cid = c.class_id;
```

## 子查询/嵌套查询

```sql
-- 如果子查询返回的结果是一个值（单列单行），条件可以直接使用关系运算符（= !=....）
select * from students where cid = (select class_id from classes where class_name='Java2205');
-- b.查询这些班级编号中的学生信息(union 将多个查询语句的结果整合在一起)
select * from students where cid=1
UNION
select * from students where cid=2
UNION
select * from students where cid=3;
-- 如果子查询返回的结果是多个值（单列多行），条件使用IN / NOT IN
select * from students where cid IN (select class_id from classes where class_name LIKE 'Java%');
-- 多条件查询：
select * from students where cid=1 and stu_gender='男';
-- 子查询:先查询cid=1班级中的所有学生信息，将这些信息作为一个整体虚拟表(多行多列)
-- 再基于这个虚拟表查询性别为男的学生信息（‘虚拟表’需要别名）
select * from (select * from students where cid=1) t where t.stu_gender='男';
```

# Redis

## **字符串操作**

1. `SET key value`：设置指定键的值。
2. `GET key`：获取指定键的值。
3. `DEL key`：删除指定键。
4. `INCR key`：将指定键的值加1。
5. `DECR key`：将指定键的值减1。
6. `APPEND key value`：将值追加到指定键的值末尾。
7. `GETRANGE key start end`：获取指定键的值的子字符串，范围是从 start 到 end。
8. `STRLEN key`：获取指定键的值的长度。
9. `SETEX key seconds value`：设置指定键的值，并指定过期时间（以秒为单位）。
10. `MSET key1 value1 key2 value2 ...`：同时设置多个键的值。
11. `MGET key1 key2 ...`：同时获取多个键的值。
12. `SETNX key value`：仅在键不存在时设置键的值。
13. `GETSET key value`：设置指定键的值，并返回键之前的旧值。

## **列表操作**

1. `LPUSH key value1 [value2 ...]`：将一个或多个值插入到列表的头部。
2. `RPUSH key value1 [value2 ...]`：将一个或多个值插入到列表的尾部。
3. `LPOP key`：移除并返回列表头部的元素。
4. `RPOP key`：移除并返回列表尾部的元素。
5. `LINDEX key index`：获取列表指定位置的元素，索引从0开始。
6. `LLEN key`：获取列表的长度。
7. `LRANGE key start stop`：获取列表指定范围内的元素，范围是从 start 到 stop。

**列表的其他操作**：

1. `LINSERT key BEFORE|AFTER pivot value`：在列表中某个元素的前面或后面插入一个新元素。
2. `LREM key count value`：从列表中删除指定数量的指定元素。
3. `LSET key index value`：将列表中指定位置的元素设置为新值。
4. `LTRIM key start stop`：保留列表中指定范围内的元素，其他元素将被删除。
5. `BLPOP key1 [key2 ...] timeout`：阻塞式弹出列表头部元素，如果列表为空，会一直等待直到有元素或超时。
6. `BRPOP key1 [key2 ...] timeout`：阻塞式弹出列表尾部元素，如果列表为空，会一直等待直到有元素或超时。

## **集合操作**

1. `SADD key member1 [member2 ...]`：将一个或多个成员添加到集合中（重复不添加）。
2. `SMEMBERS key`：获取集合中的所有成员。
3. `SISMEMBER key member`：检查成员是否存在于集合中。
4. `SREM key member1 [member2 ...]`：从集合中移除一个或多个成员。
5. `SCARD key`：获取集合的成员数（基数）。

**集合的集合操作**：

1. `SUNION key1 [key2 ...]`：返回给定集合的并集。
2. `SINTER key1 [key2 ...]`：返回给定集合的交集。
3. `SDIFF key1 [key2 ...]`：返回给定集合的差集。
4. `SUNIONSTORE destination key1 [key2 ...]`：将多个集合的并集存储在目标集合中。
5. `SINTERSTORE destination key1 [key2 ...]`：将多个集合的交集存储在目标集合中。
6. `SDIFFSTORE destination key1 [key2 ...]`：将多个集合的差集存储在目标集合中

## **哈希表操作**

1. **哈希表的基本操作**：

   1. `HSET key field value`：将哈希表中的字段设置为指定值。
   2. `HGET key field`：获取哈希表中指定字段的值。
   3. `HDEL key field1 [field2 ...]`：删除哈希表中一个或多个字段。
   4. `HEXISTS key field`：检查哈希表中是否存在指定字段。
   5. `HLEN key`：获取哈希表中字段的数量。

   **哈希表的批量操作**：

   1. `HMSET key field1 value1 [field2 value2 ...]`：同时设置多个字段的值。
   2. `HMGET key field1 [field2 ...]`：同时获取多个字段的值。

   **哈希表的遍历操作**：

   1. `HKEYS key`：获取哈希表中所有的字段名。
   2. `HVALS key`：获取哈希表中所有的字段值。
   3. `HGETALL key`：获取哈希表中所有的字段和值。

## **有序集合操作**

1. **有序集合的基本操作**：

   1. `ZADD key score1 member1 [score2 member2 ...]`：将一个或多个成员添加到有序集合中，每个成员都有一个分数。
   2. `ZRANGE key start stop [WITHSCORES]`：按分数范围获取有序集合中的成员，可以选择是否返回分数。
   3. `ZREVRANGE key start stop [WITHSCORES]`：按分数范围获取有序集合中的成员，按分数降序排列。
   4. `ZSCORE key member`：获取成员的分数。
   5. `ZREM key member1 [member2 ...]`：从有序集合中移除一个或多个成员。
   6. `ZCARD key`：获取有序集合的成员数（基数）。
   7. `ZCOUNT key min max`：计算有序集合中分数在指定范围内的成员数。
   8. `ZRANK key member`：获取成员在有序集合中的排名（从0开始）。
   9. `ZREVRANK key member`：获取成员在有序集合中的排名（按分数降序排列，从0开始）。

   **有序集合的集合操作**：

   1. `ZUNIONSTORE destination numkeys key1 [key2 ...]`：计算多个有序集合的并集，并将结果存储在目标有序集合中。
   2. `ZINTERSTORE destination numkeys key1 [key2 ...]`：计算多个有序集合的交集，并将结果存储在目标有序集合中。

## **其他常见命令**

### **键操作**：

1. `EXISTS key`：检查键是否存在。
2. `TYPE key`：获取键的数据类型。
3. `DEL key1 [key2 ...]`：删除一个或多个键。
4. `KEYS pattern`：查找与指定模式匹配的键。
5. `EXPIRE key seconds`：设置键的过期时间（以秒为单位）。
6. `TTL key`：获取键的剩余生存时间（以秒为单位）。

### **事务**：

1. `MULTI`：标记事务的开始。
2. `EXEC`：执行事务中的所有命令。
3. `DISCARD`：取消事务。
4. `WATCH key1 [key2 ...]`：监视一个或多个键，以便在事务执行时检测它们是否被修改。

**发布订阅**：

1. `SUBSCRIBE channel`：订阅一个频道。
2. `UNSUBSCRIBE [channel1 channel2 ...]`：取消订阅一个或多个频道。
3. `PUBLISH channel message`：向指定频道发布一条消息。

**服务器管理**：

1. `PING`：检查服务器是否运行。
2. `SELECT index`：选择指定的数据库。
3. `FLUSHDB`：删除当前数据库中的所有数据。
4. `FLUSHALL`：删除所有数据库中的所有数据。
5. `INFO [section]`：获取服务器的信息。
6. `SAVE`：保存数据到硬盘。
7. `BGSAVE`：在后台异步保存数据到硬盘。
8. `BGREWRITEAOF`：在后台重写日志文件。

## SpringBoot操作Redis

1. ### **设置值**：

   使用`opsForValue()`方法来设置键值对。示例：

   ```java
   redisTemplate.opsForValue().set("key", "value");
   ```

2. ### **获取值**：

   使用`opsForValue()`方法来获取值。示例：

   ```java
   String value = redisTemplate.opsForValue().get("key");
   ```

3. ### **设置带有过期时间的值**：

   使用`opsForValue()`方法来设置带有过期时间的键值对。示例：

   ```java
   redisTemplate.opsForValue().set("key", "value", 3600, TimeUnit.SECONDS); // 设置过期时间为1小时
   ```

4. ### **检查键是否存在**：

   使用`hasKey()`方法来检查键是否存在。示例：

   ```java
   boolean exists = redisTemplate.hasKey("key");
   ```
   
5. ### **删除键**：

   使用`delete()`方法来删除键。示例：

   ```java
   redisTemplate.delete("key");
   ```

6. **设置集合（List、Set、Hash等）值**：

   使用`opsForList()`、`opsForSet()`、`opsForHash()`等方法来操作不同类型的集合。示例：

   ```java
   // 设置List集合值
   redisTemplate.opsForList().leftPush("listKey", "value1");
   
   // 设置Set集合值
   redisTemplate.opsForSet().add("setKey", "value1", "value2");
   
   // 设置Hash集合值
   redisTemplate.opsForHash().put("hashKey", "field1", "value1");
   ```

7. **获取集合中的值**：

   使用`opsForList()`、`opsForSet()`、`opsForHash()`等方法来获取集合中的值。示例：

   ```java
   // 获取List集合中的值
   List<String> listValues = redisTemplate.opsForList().range("listKey", 0, -1);
   
   // 获取Set集合中的值
   Set<String> setValues = redisTemplate.opsForSet().members("setKey");
   
   // 获取Hash集合中的值
   String hashValue = (String) redisTemplate.opsForHash().get("hashKey", "field1");
   ```

8. **自增和自减**：

   使用`opsForValue()`方法来执行自增和自减操作。示例：

   ```java
   redisTemplate.opsForValue().increment("counter", 1); // 自增1
   redisTemplate.opsForValue().decrement("counter", 1); // 自减1
   ```

9. **批量操作**：

   `RedisTemplate`还支持批量操作，允许一次性执行多个操作，以提高性能。示例：

   ```java
   redisTemplate.executePipelined((RedisConnection connection) -> {
       connection.openPipeline();
       connection.set(redisTemplate.getStringSerializer().serialize("key1"), redisTemplate.getStringSerializer().serialize("value1"));
       connection.set(redisTemplate.getStringSerializer().serialize("key2"), redisTemplate.getStringSerializer().serialize("value2"));
       connection.get(redisTemplate.getStringSerializer().serialize("key1"));
       connection.get(redisTemplate.getStringSerializer().serialize("key2"));
       connection.closePipeline();
       return null;
   });
   ```

   ### 10、添加地理位置信息

   ```java
   redisTemplate.opsForGeo().add("locations",new Point(13.361389,38.115556),"locations");
   redisTemplate.opsForGeo().add("locations",new Point(15.087269, 37.502669),"locations1");
   
   //获取地理位置信息
   List<Point> position = redisTemplate.opsForGeo().position("locations", "locations1");
   for (Point point : position) {
       System.out.println(point);
   }
   //计算两个地理位置之间的距离
   Distance distance = redisTemplate.opsForGeo().distance("locations","locations", "locations1", Metrics.KILOMETERS);
   ```

   

# Docker

## 1、找镜像

（http://hub.docker.com）

```bash
docker pull nginx  #下载最新版

镜像名:版本名（标签）

docker pull nginx:1.20.1


docker pull redis  #下载最新
docker pull redis:6.2.4

## 下载来的镜像都在本地
docker images  #查看所有镜像

redis = redis:latest

docker rmi 镜像名:版本号/镜像id     #删除镜像
```

## 2、启动容器

```bash
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

【docker run  设置项   镜像名  】 镜像启动运行的命令（镜像里面默认有的，一般不会写）

# -d：后台运行
# --restart=always: 开机自启
docker run --name=mynginx   -d  --restart=always -p  88:80   nginx
docker run -d --restart=always --name my-mysql-container -e MYSQL_ROOT_PASSWORD=112233 -p 3306:3306 mysql:8.0.30
docker run -d -p 27017:27017 --name my_mongo_container --restart=always -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin mongo


# 查看正在运行的容器
docker ps
# 查看所有
docker ps -a
# 删除停止的容器
docker rm  容器id/名字
docker rm -f mynginx   #强制删除正在运行中的

#停止容器
docker stop 容器id/名字
#再次启动
docker start 容器id/名字

#应用开机自启
docker update 容器id/名字 --restart=always
--------------------------nginx----------------------------------
#docker 部署 nginx
#拉取镜像
docker pull nginx:latest

#运行nginx镜像
docker run -d -p 80:80 \
--name nginx-spzx \
-v nginx_html:/usr/share/nginx/html \
-v nginx_conf:/etc/nginx/ \
-v nginx_logs:/var/log/nginx  nginx

# nginx-spzx容器的管理命令
docker start nginx-spzx			# 启动容器
docker stop nginx-spzx			# 关闭容器
docker rm nginx-spzx			# 删除容器

#使用浏览器访问测试：http://ip
---------------------------nacos------------------------------------
# 拉取镜像
docker pull nacos/nacos-server:v2.2.2

# 创建容器
docker run --name nacos -e MODE=standalone -p 8848:8848 -p 9848:9848 -d nacos/nacos-server:v2.2.2

# nacos2.x的版本新增了一个客户端与服务端的gRpc的通讯端口号9848

startup.cmd -m standalone     windows上单机启动nacos
-----------------------------------------------------------------------
```

## 3、修改容器内容

### 1.进入容器内部修改

```bash
# 进入容器内部的系统，修改容器内容
docker exec -it 容器id  /bin/bash
```

### 2、挂载数据到外部修改

```bash
docker run --name=mynginx   \
-d  --restart=always \
-p  88:80 -v /data/html:/usr/share/nginx/html:ro  \
nginx

# 修改页面只需要去 主机的 /data/html
```

### 3、修改端口号

```bash
docker run -d -p 6380:6379 --name my-redis redis
```

## 4、提交改变

将自己修改好的镜像提交

```bash
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]

docker commit -a "leifengyang"  -m "首页变化" 341d81f7504f guignginx:v1.0
```

## 5、镜像传输

```bash
# 将镜像保存成压缩包
docker save -o abc.tar guignginx:v1.0

# 别的机器加载这个镜像
docker load -i abc.tar

# 离线安装
```

## 6、推送远程仓库

```bash
docker tag local-image:tagname new-repo:tagname
docker push new-repo:tagname
```

```bash
# 把旧镜像的名字，改成仓库要求的新版名字
docker tag guignginx:v1.0 leifengyang/guignginx:v1.0

# 登录到docker hub
docker login       


docker logout（推送完成镜像后退出）

# 推送
docker push leifengyang/guignginx:v1.0


# 别的机器下载
docker pull leifengyang/guignginx:v1.0
```

## 7、补充

```bash
docker logs 容器名/id   排错

docker exec -it 容器id /bin/bash


# docker 经常修改nginx配置文件
docker run -d -p 80:80 \
-v /data/html:/usr/share/nginx/html:ro \
-v /data/conf/nginx.conf:/etc/nginx/nginx.conf \
--name mynginx-02 \
nginx


#把容器指定位置的东西复制出来 
docker cp 5eff66eec7e1:/etc/nginx/nginx.conf  /data/conf/nginx.conf
#把外面的内容复制到容器里面
docker cp  /data/conf/nginx.conf  5eff66eec7e1:/etc/nginx/nginx.conf
```

## 8、centos下载安装jdk

```bash
yum search java|grep jdk
yum install java-1.8.0-openjdk
```

## 9、docker部署项目环境

```
docker build -t redis-demo:v1.0 -f Dockerfile .
```

Dockerfile：

```dockerfile
FROM openjdk:8-jdk-slim
LABEL maintainer=mxy

COPY target/*.jar /app.jar

ENTRYPOINT ["java","-jar","/app.jar"]
```

查看springboot运行日志

```bash
docker logs 7a3e4175ca93
docker logs -f 7a3e4175ca93    //追踪日志
```

# VUE

```
npm create vue@latest   创建VUE项目
npm run dev      运行VUE
npm init vite     创建vite项目
vue create project   使用vue/cli组件创建项目
```

# git提交

```
git init
git remote add origin git@github.com:1143238608/temple_vue.git
git pull
git branch  #查看分支
git checkout main  #切换分支
git add .
git commit -m 'templte提交'
git push origin main
```



# 考试

![image-20231217162923372](D:\test\typora_pic\image-20231217162923372.png)

![image-20231217162957517](D:\test\typora_pic\image-20231217162957517.png)

![image-20231217163022489](D:\test\typora_pic\image-20231217163022489.png)

![image-20231217163034283](D:\test\typora_pic\image-20231217163034283.png)
